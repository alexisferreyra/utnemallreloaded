import "System", "platform=DotNET", "ns=DotNET", "assembly=mscorlib";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Data";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Web.Services";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Drawing";
import "UtnEmall", "platform=DotNET", "ns=DotNET", "assemblyfilename=..\\..\\Main\\Common\\BaseDesktop\\bin\\Debug\\BaseDesktop.dll";
import "System.ServiceModel", "platform=DotNET", "ns=DotNET", "assemblyfilename=C:\\Program files\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\System.ServiceModel.dll";


using Zoe;
using zoe::lang;

using DotNET::System;
using DotNET::System::Collections;
using DotNET::System::Data;
using DotNET::System::Data::Common;
using DotNET::System::Data::SqlClient;
using DotNET::System::Diagnostics;
using DotNET::System::ServiceModel;
using DotNET::System::Globalization;

using DotNET::UtnEmall::Server::EntityModel;
using DotNET::UtnEmall::Server::DataModel;
using DotNET::UtnEmall::Server::Core;
using DotNET::UtnEmall::Server::Base;
using UtnEmall::Utils;
using DotNET::System::Collections::Generic;
using DotNET::System::Collections::ObjectModel;
using DotNET::System::Web::Services::Protocols;

namespace DotNET::UtnEmall::Server::DataModel
{
	Model::DefineMobil(false);
	Model::DefineIdentity(true);
	ModelBusiness::IsWindowsMobile(false);

	// Represents a Menu, ItemTemplate
	Model::Define(Component, false){
		// ATRIBUTOS DE COMPONENT
		// Absolute Height of ItemTempalte
		Model::Field(Height, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Height, "La altura no puede ser negativa");
		};
		// Absolute Width of ItemTempalte
		Model::Field(Width, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Width, "El ancho no puede ser negativo");
		};
		// Relative Height of ItemTempalte
		Model::Field(HeightFactor, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Height, "La altura no puede ser negativa");
		};
		// Relative Width of ItemTempalte
		Model::Field(WidthFactor, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Width, "El ancho no puede ser negativo");
		};
		// Absolute X coordinate of ItemTempalte
		Model::Field(XCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XCoordinateRelativeToParent, "XCoordinateRelativeToParent no puede ser negativo");
		};
		// Absolute Y coordinate of ItemTempalte
		Model::Field(YCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YCoordinateRelativeToParent, "YCoordinateRelativeToParent no puede ser negativo");
		};
		// Relative X coordinate of ItemTempalte
		Model::Field(XFactorCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XFactorCoordinateRelativeToParent, "XFactorCoordinateRelativeToParent no puede ser negativo");
		};
		// Relative Y coordinate of ItemTempalte
		Model::Field(YFactorCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YFactorCoordinateRelativeToParent, "YFactorCoordinateRelativeToParent no puede ser negativo");
		};


		// ATRIBUTOS DE FORMMENUITEM
		// If ItemTemplate font is Bold
		Model::Field(Bold, gettype(bool));
		// ItemTemplate FontColor
		Model::Field(FontColor, gettype(string))
		{
			//Rules::PropertyGreaterThanZero(FontColor, "FontColor can't be negative");
			Rules::PropertyStringNotEmpty(FontColor,"El color de la fuente no puede estar vacío");
		};
		// ItemTemplate FontName
		Model::Field(FontName, gettype(int))
		{
			Rules::PropertyGreaterThanZero(FontName, "El nombre de la fuente no puede ser negativo");
		};
		// ItemTemplate FontSize
		Model::Field(FontSize, gettype(int))
		{
			Rules::PropertyGreaterThanZero(FontSize, "El tamaño de la fuente no puede ser negativo");
		};
		// ItemTemplate Italic
		Model::Field(Italic, gettype(bool));
		// ItemTemplate Underline
		Model::Field(Underline, gettype(bool));
		// ItemTemplate TextAling
		Model::Field(TextAlign, gettype(int))
		{
			Rules::PropertyGreaterThanZero(TextAlign, "La alineación del texto no puede ser negativa");
		};
		// ItemTemplate Background color
		Model::Field(BackgroundColor, gettype(string))
		{
			Rules::PropertyStringNotEmpty(BackgroundColor,"El color de fondo no puede estar vacío");
			//Rules::PropertyGreaterThanZero(BackgroundColor, "BackgroundColor can't be negative");
		};

		// Text of MenuItem
		Model::Field(Text, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Text,"El campo texto no puede estar vacío");
		};

		// DataType of ItemTemplate or DataType for InsertSingleDataForm
		Model::Field(DataTypes, gettype(int))
		{
			Rules::PropertyGreaterThanZero(DataTypes, "El tipo de dato no puede ser negativo");
		};

		// ATRIBUTOS DE WIdGET

		// DELETED : ESTO SE VA ASI ROMPE TODO :-)
		//Model::Field(IsListGiver, gettype(bool));
		//Model::Field(IsRegisterGiver, gettype(bool));

		// ATRIBUTOS DE DATASOURCE
		// If DataSource will return data in ascendent or descendent order for the selected field.
		Model::Field(TypeOrder, gettype(int))
		{
			Rules::PropertyGreaterThanZero(TypeOrder, "El orden de tipos no puede ser negativo");
		};

		// ATRIBUTOS DE FORM
		// Title for the Form
		Model::Field(Title, gettype(string));
		// Help for the Form
		Model::Field(StringHelp, gettype(string));
		// ATRIBUTOS DE ENTERSINGLEDATAFORM
		// Text that help the user to know which data to enter
		Model::Field(DescriptiveText, gettype(string));
		// ATRIBUTOS DE SHOWDATAFORM
		// Defines the type of highlevel component
		Model::Field(ComponentType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ComponentType, "El tipo de componente no puede ser negativo");
		};



		// If the services ends on this form or menu item option
		Model::Field(FinalizeService, gettype(bool));

		// Relation with CustomerServiceData
		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::MuchosAUno, false, false, false, true)
		{

		};

		// The document that define the template for ListForm and ShowDataForm
		Model::Relations(TemplateListFormDocument, CustomerServiceData, RelationTypes::UnoAUno, true, true, true)
		{

		};

		// The submenus of the MenuForm
		Model::Relations(MenuItems, Component, ParentComponent, RelationTypes::UnoAMuchos, true, true, true, false, true)
		{

		};
		// The parent component :-)
		Model::Relations(ParentComponent, Component, ParentComponent, RelationTypes::MuchosAUno, true, true, false, true, true)
		{

		}; //MENUFORM

		// The Forms' or DataStores' input connection points
		Model::Relations(InputConnectionPoint, ConnectionPoint, RelationTypes::UnoAUno, true, true, true){};
		// The Forms', MenuItems' or DataSources' output connection points
		Model::Relations(OutputConnectionPoint, ConnectionPoint, RelationTypes::UnoAUno, true, true, true){};
		// The table - on the store data model - that represents the output data context
		Model::Relations(OutputDataContext, Table, RelationTypes::UnoAUno, true, false){};
		// The table - on the store data model - that represents the input data context
		Model::Relations(InputDataContext, Table, RelationTypes::UnoAUno, true, false){};
		// The table for a DataSource or DataStorage
		Model::Relations(RelatedTable, Table, RelationTypes::UnoAUno, true, false){};

		// The field to order by on DataSource
		Model::Relations(FieldToOrder, Field, RelationTypes::UnoAUno, true, false){};
		// Field of Table on DataModel associated to a TemplateListItem
		Model::Relations(FieldAssociated, Field, RelationTypes::UnoAUno, true, false){};

		// DELETED :
		//Model::Relations(FieldToSave, Field, RelationTypes::UnoAUno, true, false){};
	};

	Model::Define(CustomerServiceData, true, true){
		// ATRIBUTOS DE CustomerServiceData
		// Define if it is a TemplateListItemDocument or a CustomerServiceDataDocument
		Model::Field(CustomerServiceDataType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(CustomerServiceDataType, "El tipo de dato del servicio no puede ser negativo");
		};

		// ATRIBUTOS DE ServiceCustomerServiceData
		// List of components
		Model::Relations(Components, Component, RelationTypes::UnoAMuchos, true, true, true){};
		// List of connections
		Model::Relations(Connections, ConnectionWidget, RelationTypes::UnoAMuchos, true, true, true){};

		// DELETED : no se usa, si lo usamos deberia llamarse "Parent" o "ParentForm" para
		// apuntar al formulario padre cuando el CustomerServiceData es un TemplateDocument
		//Model::Relations(Component, Component, RelationTypes::UnoAUno, false, false){};

		// The related DataModel that the service use
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAUno, true, false){};

		// The first menu on the service
		Model::Relations(InitComponent, Component, RelationTypes::UnoAUno, true, true){};

		// The Service that define current CustomerServiceData
		Model::Relations(Service, Service, RelationTypes::UnoAUno, false, false){};
	};

	Model::Define(ConnectionWidget, false){

		// Relation with the Target Connection Point
		Model::Relations(Target, ConnectionPoint, RelationTypes::UnoAUno, true, false, false){};
		// Relation with the Source Connection Point
		Model::Relations(Source, ConnectionPoint, RelationTypes::UnoAUno, true, false, false){};

		// Relation with the Document
		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::MuchosAUno, false, false, false, true){};

		//
		//Model::Relations(Component, Component, RelationTypes::MuchosAUno, false, false){};
	};

	Model::Define(ConnectionPoint, false){
		// Define if it is a input or output Connection Point
		Model::Field(ConnectionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ConnectionType, "El tipo de conexión no puede ser negativo");
		};
		// X Coordinate on draw area
		Model::Field(XCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XCoordinateRelativeToParent, "XCoordinateRelativeToParent no puede ser negativo");
		};
		// Y Coordinate on draw area
		Model::Field(YCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YCoordinateRelativeToParent, "YCoordinateRelativeToParent no puede ser negativo");
		};
		// The component container of the connection
		Model::Relations(ParentComponent, Component, RelationTypes::UnoAUno, true, true){};
		// The relation with Component
		Model::Relations(Component, Component, RelationTypes::MuchosAUno, true, true, false, true){};

		// The relation with ConnectionWidget
		Model::Relations(ConnectionWidget, ConnectionWidget, RelationTypes::UnoAUno, true, false, false){};
	};

	Model::Define(Campaign, true, true){
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "La descripción no puede estar vacía.");
		};

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"El nombre no puede estar vacío.");
			Rules::PropertyUnique(Name, "El nombre de campaña ya existe.", Campaign);
		};
		
		Model::Field(StartDate, gettype(DateTime))
		{
			Rules::PropertyNotNull(StartDate, "La fecha de inicio no puede estar vacía.");
		};

		Model::Field(StopDate, gettype(DateTime))
		{
			Rules::PropertyDateTimeLowerThan(StopDate, StartDate, "La fecha de inicio no puede ser posterior a la de fin.");
			Rules::PropertyNotNull(StopDate, "La fecha de fin no puede estar vacía.");
		};
		
		Model::Relations(User, User, User, RelationTypes::MuchosAUno, true, false, false, true, true){};
		Model::Relations(ServiceCampaign, ServiceCampaign, RelationTypes::UnoAMuchos, false, false){};
		
		// Deletion restrictions
		Model::DeleteRestriction(ServiceCampaign, Campaign, "Hay servicios asociados a esta campaña.");
	};

	Model::Define(Category, true, true){
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "La descripción no puede estar vacía");
		};

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"El nombre no puede estar vacío");
			Rules::PropertyUnique(Name, "Nombre de categoría duplicado", Category);
		};

		Model::Relations(Childs, Category, ParentCategory, RelationTypes::UnoAMuchos, true, true, true, false, true){};
		Model::Relations(ParentCategory, Category, ParentCategory, RelationTypes::MuchosAUno, true, false, false, true, true){};

		Model::Relations(Preference, Preference, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(ServiceCategory, ServiceCategory, RelationTypes::UnoAMuchos, false, false){};
		//Model::Relations(History, History, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(StoreCategory, StoreCategory, RelationTypes::UnoAMuchos, false, false){};

		// Deletion restrictions
		Model::DeleteRestriction(StoreCategory, Category, "Existen tiendas asociadas a esta categoría.");
		Model::DeleteRestriction(ServiceCategory, Category, "Existen servicos asociados a esta categoría.");
		Model::DeleteRestriction(RegisterAssociationCategories, Category, "Existen registros asociados a esta categoría.");

		// Model::DeleteRestriction(Preference, Category, "There are preferencies of some customers associated to this category.");
	};

	Model::Define(Customer, true, true){

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "El nombre no puede estar vacío");
		};
		Model::Field(Surname, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Surname, "El apellido no puede estar vacío");
		};
		Model::Field(Address, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Address, "La dirección no puede estar vacía");
		};
		Model::Field(PhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(PhoneNumber, "El teléfono no puede estar vacío");
		};
		Model::Field(UserName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(UserName, "El nombre de usuario no puede estar vacío");
			Rules::PropertyUnique(UserName, "Nombre de usuario duplicado", Customer);
		};

		Model::Field(Password, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Password, "El password no puede estar vacío");
		};

		Model::Field(Birthday, gettype(DateTime))
		{
			Rules::PropertyNotNull(Birthday, "La fecha de cumpleaños no puede estar vacía.");
		};
		Model::Field(HowManyChildren, gettype(int)){};
		Model::Field(Gender, gettype(int)){};
		Model::Field(CivilState, gettype(int)){};

		Model::Relations(Preferences, Preference, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Preferences, "La preferencia no puede estar vacía");
		};

		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(DeviceProfile, DeviceProfile, RelationTypes::UnoAMuchos,true, true, true)
		{
			Rules::PropertyNotNull(DeviceProfile, "El perfil del dispositivo no puede ser nulo");
		};
		//Model::Relations(History, History, RelationTypes::UnoAMuchos, false, false){};

	};

	Model::Define(DataModel, true, true){
		//Model::Field(Name, gettype(string))
		//{
		//	Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
		//};
		Model::Field(ServiceAssemblyFileName, gettype(string)){};
		//Mark if the service was deployed (and builded)
		Model::Field(Deployed, gettype(bool)){};
		//Mark if the service need to be redeployed on server startup
		Model::Field(Updated, gettype(bool)){};

		Model::Relations(Tables, Table, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Tables, "El nombre de la tabla no puede estar vacío");
			Rules::PropertyCollection(Tables, Table)
			{
				Rules::PropertyStringNotEmpty(Name, "El nombre de tabla no puede estar vacío");
				Rules::CollectionNonEmpty(Fields, "El nombre de campo no puede estar vacío");
				Rules::PropertyCollection(Fields, Field)
				{
					Rules::PropertyStringNotEmpty(Name, "El nombre de campo no puede estar vacío");
					Rules::PropertyGreaterThanZero(DataType, "El tipo de dato no puede estar vacío");
				};
			};
		};

		Model::Relations(Relations, Relation, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Relations, "Las relaciones no pueden estar vacías");

			Rules::PropertyCollection(Relations, Relation)
			{
				Rules::PropertyGreaterThanZero(RelationType, "El tipo de relación no puede ser cero");
				Rules::PropertyGreaterThanZero(IdTarget, "IdTarget no puede estar vacío");
				Rules::PropertyGreaterThanZero(IdSource, "IdSource no puede estar vacío");
			};

		};
		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, true, false, false, true){};

		// Deletion restrictions
		Model::DeleteRestriction(CustomerServiceData, DataModel, "Hay servicios asociados a este modelo de datos.");

	};

	Model::Define(DeviceProfile, false){
		Model::Field(DeviceType, gettype(string))
		{
			Rules::PropertyStringNotEmpty(DeviceType,"El tipo de dispositivo no puede estar vacío");
		};
		Model::Field(DeviceModel, gettype(string))
		{
			Rules::PropertyStringNotEmpty(DeviceModel,"El modelo de dispositivo no puede estar vacío");
		};
		Model::Field(MacAddress, gettype(string))
		{
			Rules::PropertyStringNotEmpty(MacAddress,"La dirección MAC no puede estar vacío");
			Rules::PropertyUnique(MacAddress, "Dirección MAC duplicada", DeviceProfile);
		};
		Model::Field(WindowsMobileVersion, gettype(string))
		{
			Rules::PropertyStringNotEmpty(WindowsMobileVersion,"La versión de Windows Mobile no puede estar vacía");
		};

		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Field, false){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"El nombre no puede estar vacío");
		};
		Model::Field(DataType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(DataType, "El tipo de dato no puede ser negativo");
		};

		Model::Relations(Table, Table, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Group, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "El nombre no puede estar vacío");
			Rules::PropertyUnique(Name, "Nombre duplicado", Group);
		};

		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "La descripción no puede estar vacía");
		};
		Model::Field(IsGroupActive, gettype(bool));

		Model::Relations(Permissions, Permission, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Permissions, "Los permisos no pueden estar vacíos");

			Rules::PropertyCollection(Permissions, Permission)
			{
				Rules::PropertyStringNotEmpty(BusinessClassName, "El nombre de clase de negocio no puede estar vacío");
			};

			Hashtable groupPermissions = new Hashtable();
			foreach (PermissionEntity permission in group.Permissions)
            {

				if(!permission.AllowRead && !permission.AllowUpdate && !permission.AllowNew && !permission.AllowDelete)
				{
					result = false;
					group.Errors.Add(new Error(permission.BusinessClassName, "Permisos", "No se pueden establecer todos los permisos a falso para " + permission.BusinessClassName));
				}

            	if(groupPermissions.Contains(permission.BusinessClassName))
				{
					result = false;
					group.Errors.Add(new Error(permission.BusinessClassName, "Permisos", group.Name + " ya tiene permisos para " + permission.BusinessClassName));
				}
				else
				{
					groupPermissions.Add(permission.BusinessClassName, null);
				}
            }


		};

		Model::Relations(UserGroup, UserGroup, RelationTypes::UnoAMuchos, false, false){};
		// Deletion restrictions
		Model::DeleteRestriction(UserGroup, Group, "Ya existen usuarios asociados a este grupo.");
	};

	Model::Define(Mall, false){
		Model::Field(ServerName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(ServerName,"El nombre de servidor no puede estar vacío");
		};
		Model::Field(MallName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(MallName,"El nombre de la tienda no puede estar vacío");
		};

		Model::Relations(Service, Service, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(Store, Store, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(Customer, Customer, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAMuchos, false, false){};
	};

	Model::Define(Permission, false){
		Model::Field(AllowRead, gettype(bool));
		Model::Field(AllowUpdate, gettype(bool));
		Model::Field(AllowNew, gettype(bool));
		Model::Field(AllowDelete, gettype(bool));
		Model::Field(BusinessClassName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(BusinessClassName, "El nombre de la clase de negocio no puede estar vacío");
		};

		Model::Relations(Group, Group, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Preference, false){
		Model::Field(Active, gettype(bool));
		Model::Field(Level, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Level, "El nivel no puede ser negativo");
		};
		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Category, Category, Preference, RelationTypes::MuchosAUno, true, false, false, true, false)
		{
			Rules::PropertyNotNull(Category, "La categoria no puede ser nula");
		};
	};

	Model::Define(Relation, false){
		Model::Field(RelationType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(RelationType, "El tipo de relación no puede ser negativo");
		};

		Model::Relations(Target, Table, RelationTypes::UnoAUno, true, false){};
		Model::Relations(Source, Table, RelationTypes::UnoAUno, true, false){};

		Model::Relations(DataModel, DataModel, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Service, true, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "El nombre no puede estar vacío");
			Rules::PropertyUnique(Name, "Ya existe un servicio con el mismo nombre", Service);
		};
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "La descripción no puede estar vacía");
		};

		Model::Field(WebAccess, gettype(string));
		Model::Field(RelativePathAssembly, gettype(string));

		Model::Field(PathAssemblyServer, gettype(string));

		Model::Field(Active, gettype(bool));
		Model::Field(Global, gettype(bool));

		Model::Field(Image, gettype(string));

		Model::Field(Website, gettype(string));

		//Mark if the service was deployed (and builded)
		Model::Field(Deployed, gettype(bool)){};
		//Mark if the service need to be redeployed on server startup
		Model::Field(Updated, gettype(bool)){};

		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true)
		{
			if (service.Store != null)
            {
                foreach (ServiceCategoryEntity serviceCategory in service.ServiceCategory)
                {
                    CategoryEntity categoryService = serviceCategory.Category;
                    bool isCategoryOfTheStore = false;
                    foreach (StoreCategoryEntity storeCategory in service.Store.StoreCategory)
                    {
                        CategoryEntity categoryStore = storeCategory.Category;
                        if (categoryService.Id == categoryStore.Id)
                        {
                            isCategoryOfTheStore = true;
                        }
                    }
                    result = isCategoryOfTheStore;
                    service.Errors.Add(new Error(categoryService.Name, "Categoria de Servicio", categoryService.Name + " no es una categoría de la tienda"));
                }
            }
		};
		//Model::Relations(Statistics, Statistics, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(ServiceCategory, ServiceCategory, RelationTypes::UnoAMuchos, true, true, true)
		{
			/*Rules::CollectionNonEmpty(ServiceCategory, "ServiceCategory can't be empty");

			Rules::PropertyCollection(ServiceCategory, ServiceCategory)
			{
				Rules::PropertyNotNull(Category, "Category can't be empty");
			};*/
		};

		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::UnoAUno, true, true, true)
		{
			//Rules::PropertyNotNull(CustomerServiceData, "CustomerServiceData can't be empty");
		};

		Model::Field(StartDate, gettype(DateTime))
		{
			Rules::PropertyNotNull(StartDate, "La fecha de inicio no puede ser nula");
		};

		Model::Field(StopDate, gettype(DateTime))
		{
			Rules::PropertyDateTimeLowerThan(StopDate, StartDate, "La fecha de finalización no puede ser menor a la fecha de inicio");
			Rules::PropertyNotNull(StopDate, "La fecha de finalización no puede ser nula");
		};
	};

	Model::Define(ServiceCategory, false){
		Model::Relations(Service, Service, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Category, Category, RelationTypes::MuchosAUno, true, false, false, true){};
	};

	Model::Define(ServiceCampaign, false){
		Model::Relations(Service, Service, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Campaign, Campaign, RelationTypes::MuchosAUno, true, false, false, true){};
	};
	
	Model::Define(Store, true, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "El nombre no puede estar vacío");
			Rules::PropertyUnique(Name, "Ya existe una tienda con ese nombre", Store);
		};

		Model::Field(TelephoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(TelephoneNumber, "El número de teléfono no puede estar vacío");
		};

		Model::Field(InternalPhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(InternalPhoneNumber, "El número de teléfono interno no puede estar vacío");
		};

		Model::Field(ContactName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(ContactName, "El contacto no puede estar vacío");
		};
		Model::Field(OwnerName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(OwnerName, "El campo dueño no puede estar vacío");
		};

		Model::Field(Email, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Email, "El campo correo electrónico no puede estar vacío");
		};

		Model::Field(WebAddress, gettype(string));

		Model::Field(LocalNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(LocalNumber, "El número de local no puede estar vacío");
			Rules::PropertyUnique(Name, "Ya existe un servicio con el mismo número de local", Store);
		};

		Model::Relations(StoreCategory, StoreCategory, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(StoreCategory, "La categoría no puede estar vacía");
			Rules::PropertyCollection(StoreCategory, StoreCategory)
			{
				Rules::PropertyNotNull(Category, "La categoría no puede estar vacía");
			};
		};

		Model::Relations(Service, Service, RelationTypes::UnoAMuchos, false, false)
		{
			Rules::CollectionNonEmpty(Service, "El servicio no puede estar vacío");
		};
		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAUno, false, false){};
		Model::Relations(User, User, RelationTypes::UnoAMuchos, false, false){};

	};

	Model::Define(StoreCategory, false){
		Model::Relations(Category, Category, RelationTypes::MuchosAUno, true, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true){};

	};

	Model::Define(Table, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"El nombre no puede estar vacío");
		};
		Model::Field(IsStorage, gettype(bool));
		Model::Relations(Fields, Field, RelationTypes::UnoAMuchos, true, true, true){};
		Model::Relations(DataModel, DataModel, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Component, Component, RelationTypes::UnoAUno, true, true, true){};
	};

	Model::Define(User, true){
		Model::Field(UserName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(UserName, "Nombre de usuario no puede estar vacío");
			Rules::PropertyUnique(UserName, "Nombre de usuario duplicado", User);

		};

		Model::Field(Password, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Password, "La contraseña no puede estar vacía");
		};

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "El nombre no puede estar vacío");
		};

		Model::Field(Surname, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Surname, "El apellido no puede estar vacío");
		};

		Model::Field(PhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(PhoneNumber, "El número de teléfono no puede estar vacío");
		};

		Model::Field(IsUserActive, gettype(bool));

		Model::Field(Charge, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Charge, "El cargo no puede estar vacío");
		};

		Model::Relations(UserGroup, UserGroup, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(UserGroup, "El grupo de usuario no puede estar vacío");
			Rules::PropertyCollection(UserGroup, UserGroup)
			{
				Rules::PropertyNotNull(Group, "El grupo no puede estar vacío");
			};
		};

		//Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true){};

	};

	Model::Define(UserGroup, false){
		Model::Relations(Group, Group, RelationTypes::MuchosAUno, true, false, false, true)
		{
			Rules::PropertyNotNull(Group, "El grupo no puede estar vacío");
		};
		Model::Relations(User, User, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Seek stadistical data about services usage
	Model::Define(UserAction, true){
		// An integer that mark the type of the action
		Model::Field(ActionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ActionType, "El tipo de acción no puede ser negativo");
		};
		// The Start time of the action
		Model::Field(Start, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Start, "La fecha de inicio no puede ser mayor a la fecha actual");
			Rules::PropertyNotNull(Start, "El inicio no puede ser nulo");
		};
		// The End time of the action
		Model::Field(Stop, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Stop, "La fecha de finalización no puede ser mayor a la fecha actual");
			Rules::PropertyDateTimeLowerThan(Stop, Start, "La fecha de finalización no puede ser menor a la fecha de inicio");
			Rules::PropertyNotNull(Stop, "La fecha de finalización no puede ser nula");
		};
		// The Id of the Table on the related data model (when it is applicable)
		Model::Field(IdTable, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdTable, "IdTable can't be negative");
		};
		// The Id of the register on the related data model (when it is applicable)
		Model::Field(IdRegister, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdRegister, "IdRegister can't be negative");
		};
		// The Component that launch the action on the designed Custom Service. This can be
		// a form, or menuitem
		Model::Field(IdComponent, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdComponent, "IdComponent can't be negative");
		};
		// The Id of the service
		Model::Field(IdService, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdService, "El id de servicio no puede ser negativo");
		};
		// The customer that launch the action
		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Seek stadistical data about services usage. Used on client and for interface
	// between Server and Client
	Model::Define(UserActionClientData, true){
		// An integer that mark the type of the action
		Model::Field(ActionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ActionType, "El tipo de acción no puede ser negativo");
		};
		// The Start time of the action
		Model::Field(Start, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Start, "La fecha de inicio no puede ser mayor a la fecha actual");
			Rules::PropertyNotNull(Start, "La fecha de inicio no puede ser nula");
		};
		// The End time of the action
		Model::Field(Stop, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Stop, "La fecha de finalización no puede ser mayor a la fecha actual");
			Rules::PropertyDateTimeLowerThan(Stop, Start, "La fecha de finalización no puede ser menor a la fecha de inicio");
			Rules::PropertyNotNull(Stop, "La fecha de finalización no puede ser nula");
		};
		// The Id of the Table on the related data model (when it is applicable)
		Model::Field(IdTable, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdTable, "El id de tabla no puede ser negativo");
		};
		// The Id of the register on the related data model (when it is applicable)
		Model::Field(IdRegister, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdRegister, "El id de registro no puede ser negativo");
		};
		// The Component that launch the action on the designed Custom Service. This can be
		// a form, or menuitem
		Model::Field(IdComponent, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdComponent, "El id de componente no puede ser negativo");
		};
		// The Id of the service
		Model::Field(IdService, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdService, "El id de servicio no puede ser negativo");
		};
	};

	// Relates registers on tables of datamodels with categories
	Model::Define(RegisterAssociation, true){
		Model::Field(IdRegister, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdRegister, "El id de formulario no puede ser negativo");
		};
		Model::Relations(Table, Table, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(RegisterAssociationCategories, RegisterAssociationCategories, RelationTypes::UnoAMuchos, true, true, true, false){};
	};

	Model::Define(RegisterAssociationCategories, false){
		Model::Relations(Category, Category, RelationTypes::UnoAUno, false, false, false, true){};
		Model::Relations(RegisterAssociation, RegisterAssociation, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Bloque custom para el save de Category
	ModelBusiness::CustomSave(Category){
		if(categoryEntity.IsNew){
			categoryDataAccess.Save(categoryEntity);
			PreferenceDecorator::AddNewPreferencesDueToNewCategory(categoryEntity);
		}
		else{
			categoryDataAccess.Save(categoryEntity);
		}
		return null;
	};
	// Bloque custom para el delete de Category
	ModelBusiness::CustomDelete(Category){
		// Delete categoryEntity using data access object
		categoryDataAccess.Delete(categoryEntity);
		// Delete related customers' preference
		PreferenceDataAccess^ preferenceDataAccess = new PreferenceDataAccess();
        foreach (PreferenceEntity^ preferenceEntity in preferenceDataAccess.LoadWhere(PreferenceEntity::DBIdCategory, categoryEntity.Id, false, OperatorType::Equal))
		{
			preferenceDataAccess.Delete(preferenceEntity);
		}
		return null;
	};
	// Bloque custom para el save de Customer
	ModelBusiness::CustomSave(Customer){
		if(customerEntity.IsNew){
			customerDataAccess.Save(customerEntity);
			PreferenceDecorator::AddNewPreferencesDueToNewCustomer(customerEntity);
		}
		else{
			customerDataAccess.Save(customerEntity);
		}
		return null;
	};
	// Bloque custom para el save de Category
	ModelBusiness::CustomSave(Service){
		// Check that the service is not deployed
		if(serviceEntity.Deployed){
			serviceEntity.Errors.Add(new Error("Service Deployed", "", "The service is already deployed. Can not be saved.")); 
			return serviceEntity;
		}
		serviceDataAccess.Save(serviceEntity);
		return null;
	};
	// Bloque custom delete para el Data Model
	ModelBusiness::CustomDelete(DataModel){
		// Check that the service is not deployed
		if (dataModelEntity.Deployed)
		{
			dataModelEntity.Errors.Add(new Error("DataModel Deployed", "", "The data model is already deployed. Can not be deleted.")); 
			return dataModelEntity;
		}
		// Delete dataModelEntity using data access object
		datamodelDataAccess.Delete(dataModelEntity);
		return null;
	};
	// Bloque custom save para el Data Model
	ModelBusiness::CustomSave(DataModel){
		// Check that the service is not deployed
		if (dataModelEntity.Deployed)
		{
			dataModelEntity.Errors.Add(new Error("DataModel Deployed", "", "The data model is already deployed. Can not be saved."));
			return dataModelEntity;
		}

		// Check that there isn't related custom services
		if (dataModelEntity.Id > 0)
		{
			DotNET::UtnEmall::Server::DataModel::CustomerServiceDataDataAccess^ customerServiceData = new DotNET::UtnEmall::Server::DataModel::CustomerServiceDataDataAccess();
			// Get all customer services where IdDataModel is the same as us
			int referencedServices = customerServiceData.LoadWhere(DotNET::UtnEmall::Server::EntityModel::CustomerServiceDataEntity::DBIdDataModel, dataModelEntity.Id, false, DotNET::UtnEmall::Server::Base::OperatorType::Equal).Count;
			// If there are customer services it is an error
			if (referencedServices > 0)
			{
				dataModelEntity.Errors.Add(new Error("DataModel Deployed", "", "The data model has related customer services. Can not be updated.")); 
				return dataModelEntity;
			}
		}

		// Save dataModelEntity using data access object
		datamodelDataAccess.Save(dataModelEntity);
		return null;
	};
}

// Clases externas redefinidas en Meta D++
namespace DotNET::UtnEmall::Server::BusinessLogic{
	extern class PreferenceDecorator{
    public:
		extern static void AddNewPreferencesDueToNewCategory(CategoryEntity*ref category);
        extern static void AddNewPreferencesDueToNewCustomer(CustomerEntity*ref customer);
	}
}
