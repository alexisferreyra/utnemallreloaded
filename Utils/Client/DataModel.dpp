import "System", "platform=DotNET", "ns=DotNET", "assembly=mscorlib";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Data";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Web.Services";
import "System", "platform=DotNET", "ns=DotNET", "assembly=System.Drawing";
import "UtnEmall", "platform=DotNET", "ns=DotNET", "assemblyfilename=..\\..\\Main\\Common\\BaseDesktop\\bin\\Debug\\BaseDesktop.dll";
import "System.ServiceModel", "platform=DotNET", "ns=DotNET", "assemblyfilename=C:\\Program files\\Reference Assemblies\\Microsoft\\Framework\\v3.0\\System.ServiceModel.dll";


using Zoe;
using zoe::lang;

using DotNET::System;
using DotNET::System::Collections;
using DotNET::System::Data;
using DotNET::System::Data::Common;
using DotNET::System::Data::SqlClient;
using DotNET::System::Diagnostics;
using DotNET::System::ServiceModel;
using DotNET::System::Globalization;

using DotNET::UtnEmall::Server::EntityModel;
using DotNET::UtnEmall::Server::DataModel;
using DotNET::UtnEmall::Server::Core;
using DotNET::UtnEmall::Server::Base;
using UtnEmall::Utils;
using DotNET::System::Collections::Generic;
using DotNET::System::Collections::ObjectModel;
using DotNET::System::Web::Services::Protocols;

namespace DotNET::UtnEmall::Server::DataModel
{
	Model::DefineMobil(false);
	Model::DefineIdentity(true);
	ModelBusiness::IsWindowsMobile(false);

	// Represents a Menu, ItemTemplate
	Model::Define(Component, false){
		// ATRIBUTOS DE COMPONENT
		// Absolute Height of ItemTempalte
		Model::Field(Height, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Height, "Height can't be negative");
		};
		// Absolute Width of ItemTempalte
		Model::Field(Width, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Width, "Width can't be negative");
		};
		// Relative Height of ItemTempalte
		Model::Field(HeightFactor, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Height, "Height can't be negative");
		};
		// Relative Width of ItemTempalte
		Model::Field(WidthFactor, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Width, "Width can't be negative");
		};
		// Absolute X coordinate of ItemTempalte
		Model::Field(XCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XCoordinateRelativeToParent, "XCoordinateRelativeToParent can't be negative");
		};
		// Absolute Y coordinate of ItemTempalte
		Model::Field(YCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YCoordinateRelativeToParent, "YCoordinateRelativeToParent can't be negative");
		};
		// Relative X coordinate of ItemTempalte
		Model::Field(XFactorCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XFactorCoordinateRelativeToParent, "XFactorCoordinateRelativeToParent can't be negative");
		};
		// Relative Y coordinate of ItemTempalte
		Model::Field(YFactorCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YFactorCoordinateRelativeToParent, "YFactorCoordinateRelativeToParent can't be negative");
		};


		// ATRIBUTOS DE FORMMENUITEM
		// If ItemTemplate font is Bold 
		Model::Field(Bold, gettype(bool));
		// ItemTemplate FontColor
		Model::Field(FontColor, gettype(string))
		{
			//Rules::PropertyGreaterThanZero(FontColor, "FontColor can't be negative");
			Rules::PropertyStringNotEmpty(FontColor,"Font color can't be empty");
		};
		// ItemTemplate FontName
		Model::Field(FontName, gettype(int))
		{
			Rules::PropertyGreaterThanZero(FontName, "Font name can't be negative");
		};
		// ItemTemplate FontSize
		Model::Field(FontSize, gettype(int))
		{
			Rules::PropertyGreaterThanZero(FontSize, "Font size can't be negative");
		};
		// ItemTemplate Italic
		Model::Field(Italic, gettype(bool));
		// ItemTemplate Underline
		Model::Field(Underline, gettype(bool));
		// ItemTemplate TextAling
		Model::Field(TextAlign, gettype(int))
		{
			Rules::PropertyGreaterThanZero(TextAlign, "Text align can't be negative");
		};
		// ItemTemplate Background color
		Model::Field(BackgroundColor, gettype(string))
		{
			Rules::PropertyStringNotEmpty(BackgroundColor,"Background color can't be empty");
			//Rules::PropertyGreaterThanZero(BackgroundColor, "BackgroundColor can't be negative");
		};

		// Text of MenuItem
		Model::Field(Text, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Text,"Text can't be empty");
		};
		
		// DataType of ItemTemplate or DataType for InsertSingleDataForm
		Model::Field(DataTypes, gettype(int))
		{
			Rules::PropertyGreaterThanZero(DataTypes, "DataTypes can't be negative");
		};
		
		// ATRIBUTOS DE WIdGET
		
		// DELETED : ESTO SE VA ASI ROMPE TODO :-)
		//Model::Field(IsListGiver, gettype(bool));
		//Model::Field(IsRegisterGiver, gettype(bool));
		
		// ATRIBUTOS DE DATASOURCE
		// If DataSource will return data in ascendent or descendent order for the selected field.
		Model::Field(TypeOrder, gettype(int))
		{
			Rules::PropertyGreaterThanZero(TypeOrder, "TypeOrder can't be negative");
		};

		// ATRIBUTOS DE FORM
		// Title for the Form
		Model::Field(Title, gettype(string));
		// Help for the Form
		Model::Field(StringHelp, gettype(string));
		// ATRIBUTOS DE ENTERSINGLEDATAFORM
		// Text that help the user to know which data to enter
		Model::Field(DescriptiveText, gettype(string));
		// ATRIBUTOS DE SHOWDATAFORM
		// Defines the type of highlevel component
		Model::Field(ComponentType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ComponentType, "ComponentType can't be negative");
		};



		// If the services ends on this form or menu item option
		Model::Field(FinalizeService, gettype(bool));

		// Relation with CustomerServiceData
		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::MuchosAUno, false, false, false, true)
		{

		};

		// The document that define the template for ListForm and ShowDataForm
		Model::Relations(TemplateListFormDocument, CustomerServiceData, RelationTypes::UnoAUno, true, true, true)
		{

		};

		// The submenus of the MenuForm
		Model::Relations(MenuItems, Component, ParentComponent, RelationTypes::UnoAMuchos, true, true, true, false, true)
		{

		};
		// The parent component :-)
		Model::Relations(ParentComponent, Component, ParentComponent, RelationTypes::MuchosAUno, true, true, false, true, true)
		{

		}; //MENUFORM

		// The Forms' or DataStores' input connection points 
		Model::Relations(InputConnectionPoint, ConnectionPoint, RelationTypes::UnoAUno, true, true, true){};
		// The Forms', MenuItems' or DataSources' output connection points
		Model::Relations(OutputConnectionPoint, ConnectionPoint, RelationTypes::UnoAUno, true, true, true){};
		// The table - on the store data model - that represents the output data context
		Model::Relations(OutputDataContext, Table, RelationTypes::UnoAUno, true, false){};
		// The table - on the store data model - that represents the input data context
		Model::Relations(InputDataContext, Table, RelationTypes::UnoAUno, true, false){};
		// The table for a DataSource or DataStorage
		Model::Relations(RelatedTable, Table, RelationTypes::UnoAUno, true, false){};

		// The field to order by on DataSource
		Model::Relations(FieldToOrder, Field, RelationTypes::UnoAUno, true, false){};
		// Field of Table on DataModel associated to a TemplateListItem
		Model::Relations(FieldAssociated, Field, RelationTypes::UnoAUno, true, false){};

		// DELETED :
		//Model::Relations(FieldToSave, Field, RelationTypes::UnoAUno, true, false){};
	};

	Model::Define(CustomerServiceData, true, true){
		// ATRIBUTOS DE CustomerServiceData
		// Define if it is a TemplateListItemDocument or a CustomerServiceDataDocument
		Model::Field(CustomerServiceDataType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(CustomerServiceDataType, "CustomerServiceDataType can't be negative");
		};

		// ATRIBUTOS DE ServiceCustomerServiceData
		// List of components
		Model::Relations(Components, Component, RelationTypes::UnoAMuchos, true, true, true){};
		// List of connections
		Model::Relations(Connections, ConnectionWidget, RelationTypes::UnoAMuchos, true, true, true){};
		
		// DELETED : no se usa, si lo usamos deberia llamarse "Parent" o "ParentForm" para
		// apuntar al formulario padre cuando el CustomerServiceData es un TemplateDocument
		//Model::Relations(Component, Component, RelationTypes::UnoAUno, false, false){};

		// The related DataModel that the service use
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAUno, true, false){};

		// The first menu on the service
		Model::Relations(InitComponent, Component, RelationTypes::UnoAUno, true, true){};

		// The Service that define current CustomerServiceData
		Model::Relations(Service, Service, RelationTypes::UnoAUno, false, false){};
	};

	Model::Define(ConnectionWidget, false){

		// Relation with the Target Connection Point
		Model::Relations(Target, ConnectionPoint, RelationTypes::UnoAUno, true, false, false){};
		// Relation with the Source Connection Point
		Model::Relations(Source, ConnectionPoint, RelationTypes::UnoAUno, true, false, false){};
		
		// Relation with the Document
		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::MuchosAUno, false, false, false, true){};
		
		//
		//Model::Relations(Component, Component, RelationTypes::MuchosAUno, false, false){};
	};

	Model::Define(ConnectionPoint, false){
		// Define if it is a input or output Connection Point
		Model::Field(ConnectionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ConnectionType, "ConnectionType can't be negative");
		};
		// X Coordinate on draw area
		Model::Field(XCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(XCoordinateRelativeToParent, "XCoordinateRelativeToParent can't be negative");
		};
		// Y Coordinate on draw area
		Model::Field(YCoordinateRelativeToParent, gettype(double))
		{
			Rules::PropertyGreaterThanZero(YCoordinateRelativeToParent, "YCoordinateRelativeToParent can't be negative");
		};
		// The component container of the connection
		Model::Relations(ParentComponent, Component, RelationTypes::UnoAUno, true, true){};
		// The relation with Component
		Model::Relations(Component, Component, RelationTypes::MuchosAUno, true, true, false, true){};

		// The relation with ConnectionWidget
		Model::Relations(ConnectionWidget, ConnectionWidget, RelationTypes::UnoAUno, true, false, false){};
	};
	
	Model::Define(Campaign, true, true){
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "Description can't be empty");
		};

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"Name can't be empty");
			Rules::PropertyUnique(Name, "Duplicated name for campaign", Campaign);
		};
		
		Model::Field(StartDate, gettype(DateTime))
		{
			Rules::PropertyNotNull(StartDate, "Start date can't be null");
		};

		Model::Field(StopDate, gettype(DateTime))
		{
			Rules::PropertyDateTimeLowerThan(StopDate, StartDate, "Stop date can't be lower than start date");
			Rules::PropertyNotNull(StopDate, "Stop date can't be null");
		};
		
		Model::Relations(User, User, User, RelationTypes::MuchosAUno, true, false, false, true, true){};
		Model::Relations(ServiceCampaign, ServiceCampaign, RelationTypes::UnoAMuchos, false, false){};
		
		// Deletion restrictions
		Model::DeleteRestriction(ServiceCampaign, Campaign, "There are services associated to this campaign.");
	};

	Model::Define(Category, true, true){
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "Description can't be empty");
		};

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"Name can't be empty");
			Rules::PropertyUnique(Name, "Duplicated name for category", Category);
		};
		
		Model::Relations(Childs, Category, ParentCategory, RelationTypes::UnoAMuchos, true, true, true, false, true){};
		Model::Relations(ParentCategory, Category, ParentCategory, RelationTypes::MuchosAUno, true, false, false, true, true){};
		
		Model::Relations(Preference, Preference, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(ServiceCategory, ServiceCategory, RelationTypes::UnoAMuchos, false, false){};
		//Model::Relations(History, History, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(StoreCategory, StoreCategory, RelationTypes::UnoAMuchos, false, false){};
		
		// Deletion restrictions
		Model::DeleteRestriction(StoreCategory, Category, "There are stores associated to this category.");
		Model::DeleteRestriction(ServiceCategory, Category, "There are services associated to this category.");
		Model::DeleteRestriction(RegisterAssociationCategories, Category, "There are registers associated to this category.");

		// Model::DeleteRestriction(Preference, Category, "There are preferencies of some customers associated to this category.");		
	};

	Model::Define(Customer, true, true){

		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
		};
		Model::Field(Surname, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Surname, "Surname can't be empty");
		};
		Model::Field(Address, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Address, "Address can't be empty");
		};
		Model::Field(PhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(PhoneNumber, "Phone Number can't be empty");
		};
		Model::Field(Birthday, gettype(DateTime))
		{
			Rules::PropertyNotNull(Birthday, "Birthday can't be null");
		};
		Model::Field(HowManyChildren, gettype(int)){};
		Model::Field(Gender, gettype(int)){};
		Model::Field(CivilState, gettype(int)){};
		Model::Field(UserName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(UserName, "UserName can't be empty");
			Rules::PropertyUnique(UserName, "Duplicated userName", Customer);
		};

		Model::Field(Password, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Password, "Password can't be empty");
		};

		
		Model::Relations(Preferences, Preference, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Preferences, "Preferences can't be empty");
		};
		
		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(DeviceProfile, DeviceProfile, RelationTypes::UnoAMuchos,true, true, true)
		{
			Rules::PropertyNotNull(DeviceProfile, "Device Profile can't be null");
		};
		//Model::Relations(History, History, RelationTypes::UnoAMuchos, false, false){};
				
	};

	Model::Define(DataModel, true, true){
		//Model::Field(Name, gettype(string))
		//{
		//	Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
		//};
		Model::Field(ServiceAssemblyFileName, gettype(string)){};
		//Mark if the service was deployed (and builded)
		Model::Field(Deployed, gettype(bool)){};
		//Mark if the service need to be redeployed on server startup
		Model::Field(Updated, gettype(bool)){};

		Model::Relations(Tables, Table, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Tables, "Table can't be empty");
			Rules::PropertyCollection(Tables, Table)
			{
				Rules::PropertyStringNotEmpty(Name, "Name of table can't be empty");
				Rules::CollectionNonEmpty(Fields, "Field can't be empty");
				Rules::PropertyCollection(Fields, Field)
				{
					Rules::PropertyStringNotEmpty(Name, "Name of field can't be empty");
					Rules::PropertyGreaterThanZero(DataType, "DataType can't be empty");
				};
			};
		};

		Model::Relations(Relations, Relation, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Relations, "Relations can't be empty");
			
			Rules::PropertyCollection(Relations, Relation)
			{
				Rules::PropertyGreaterThanZero(RelationType, "Relation Type can't be zero");
				Rules::PropertyGreaterThanZero(IdTarget, "IdTarget can't be empty");
				Rules::PropertyGreaterThanZero(IdSource, "IdSource can't be empty");
			};

		};
		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, true, false, false, true){};
		
		// Deletion restrictions
		Model::DeleteRestriction(CustomerServiceData, DataModel, "There are customer services associated to this data model.");
				
	};

	Model::Define(DeviceProfile, false){
		Model::Field(DeviceType, gettype(string))
		{
			Rules::PropertyStringNotEmpty(DeviceType,"DeviceType can't be empty");
		};
		Model::Field(DeviceModel, gettype(string))
		{
			Rules::PropertyStringNotEmpty(DeviceModel,"DeviceModel can't be empty");
		};
		Model::Field(MacAddress, gettype(string))
		{
			Rules::PropertyStringNotEmpty(MacAddress,"MacAddress can't be empty");
			Rules::PropertyUnique(MacAddress, "MAC Address duplicated for Device", DeviceProfile);
		};
		Model::Field(WindowsMobileVersion, gettype(string))
		{
			Rules::PropertyStringNotEmpty(WindowsMobileVersion,"WindowsMobileVersion can't be empty");
		};

		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Field, false){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"Name can't be empty");
		};
		Model::Field(DataType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(DataType, "DataType can't be negative");
		};

		Model::Relations(Table, Table, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Group, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
			Rules::PropertyUnique(Name, "Duplicated name for group", Group);
		};

		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "Description can't be empty");
		};
		Model::Field(IsGroupActive, gettype(bool));

		Model::Relations(Permissions, Permission, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(Permissions, "Permissions can't be empty");

			Rules::PropertyCollection(Permissions, Permission)
			{
				Rules::PropertyStringNotEmpty(BusinessClassName, "BusinessClassName can't be empty");
			};

			Hashtable groupPermissions = new Hashtable();
			foreach (PermissionEntity permission in group.Permissions)
            {

				if(!permission.AllowRead && !permission.AllowUpdate && !permission.AllowNew && !permission.AllowDelete)
				{
					result = false;
					group.Errors.Add(new Error(permission.BusinessClassName, "Permissions", "Can't set all permission with false to " + permission.BusinessClassName));
				}

            	if(groupPermissions.Contains(permission.BusinessClassName))
				{
					result = false;
					group.Errors.Add(new Error(permission.BusinessClassName, "Permissions", group.Name + " has already a permission for " + permission.BusinessClassName));
				}
				else
				{
					groupPermissions.Add(permission.BusinessClassName, null);
				}
            }

			
		};

		Model::Relations(UserGroup, UserGroup, RelationTypes::UnoAMuchos, false, false){};


		// Deletion restrictions
		Model::DeleteRestriction(UserGroup, Group, "There are users associated to this group.");		
	};

	Model::Define(Mall, false){
		Model::Field(ServerName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(ServerName,"ServerName can't be empty");
		};
		Model::Field(MallName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(MallName,"MallName can't be empty");
		};

		Model::Relations(Service, Service, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(Store, Store, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(Customer, Customer, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAMuchos, false, false){};
	};

	Model::Define(Permission, false){
		Model::Field(AllowRead, gettype(bool));
		Model::Field(AllowUpdate, gettype(bool));
		Model::Field(AllowNew, gettype(bool));
		Model::Field(AllowDelete, gettype(bool));
		Model::Field(BusinessClassName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(BusinessClassName, "Business class name can't be empty");
		};

		Model::Relations(Group, Group, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Preference, false){
		Model::Field(Active, gettype(bool));
		Model::Field(Level, gettype(double))
		{
			Rules::PropertyGreaterThanZero(Level, "Level can't be negative");
		};
		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Category, Category, Preference, RelationTypes::MuchosAUno, true, false, false, true, false)
		{
			Rules::PropertyNotNull(Category, "Category can't be null");
		};
	};
	
	Model::Define(Relation, false){
		Model::Field(RelationType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(RelationType, "RelationType can't be negative");
		};
		
		Model::Relations(Target, Table, RelationTypes::UnoAUno, true, false){};
		Model::Relations(Source, Table, RelationTypes::UnoAUno, true, false){};

		Model::Relations(DataModel, DataModel, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	Model::Define(Service, true, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
			Rules::PropertyUnique(Name, "A service with that name already exists", Service);
		};
		Model::Field(Description, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Description, "Description can't be empty");
		};
		
		Model::Field(WebAccess, gettype(string));		
		Model::Field(RelativePathAssembly, gettype(string));

		Model::Field(PathAssemblyServer, gettype(string));

		Model::Field(Active, gettype(bool));
		Model::Field(Global, gettype(bool));

		Model::Field(Image, gettype(string));
		
		Model::Field(Website, gettype(string));

		//Mark if the service was deployed (and builded)
		Model::Field(Deployed, gettype(bool)){};
		//Mark if the service need to be redeployed on server startup
		Model::Field(Updated, gettype(bool)){};

		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true)
		{
			if (service.Store != null)
            {
                foreach (ServiceCategoryEntity serviceCategory in service.ServiceCategory)
                {
                    CategoryEntity categoryService = serviceCategory.Category;
                    bool isCategoryOfTheStore = false;
                    foreach (StoreCategoryEntity storeCategory in service.Store.StoreCategory)
                    {
                        CategoryEntity categoryStore = storeCategory.Category;
                        if (categoryService.Id == categoryStore.Id)
                        {
                            isCategoryOfTheStore = true;
                        }
                    }
                    result = isCategoryOfTheStore;
                    service.Errors.Add(new Error(categoryService.Name, "Service Category", categoryService.Name + "is not a category of the store"));
                }
            }
		};
		//Model::Relations(Statistics, Statistics, RelationTypes::UnoAMuchos, false, false){};
		Model::Relations(ServiceCategory, ServiceCategory, RelationTypes::UnoAMuchos, true, true, true)
		{
			/*Rules::CollectionNonEmpty(ServiceCategory, "ServiceCategory can't be empty");

			Rules::PropertyCollection(ServiceCategory, ServiceCategory)
			{
				Rules::PropertyNotNull(Category, "Category can't be empty");
			};*/
		};

		Model::Relations(CustomerServiceData, CustomerServiceData, RelationTypes::UnoAUno, true, true, true)
		{
			//Rules::PropertyNotNull(CustomerServiceData, "CustomerServiceData can't be empty");
		};
		
		Model::Field(StartDate, gettype(DateTime))
		{
			Rules::PropertyNotNull(StartDate, "Start date can't be null");
		};

		Model::Field(StopDate, gettype(DateTime))
		{
			Rules::PropertyDateTimeLowerThan(StopDate, StartDate, "Stop date can't be lower than start date");
			Rules::PropertyNotNull(StopDate, "Stop date can't be null");
		};
	};

	Model::Define(ServiceCampaign, false){
		Model::Relations(Service, Service, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Campaign, Campaign, RelationTypes::MuchosAUno, true, false, false, true){};
		
	};

	Model::Define(ServiceCategory, false){
		Model::Relations(Service, Service, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Category, Category, RelationTypes::MuchosAUno, true, false, false, true){};
		
	};

	Model::Define(Store, true, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
			Rules::PropertyUnique(Name, "A store with that name already exists", Store);
		};

		Model::Field(TelephoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(TelephoneNumber, "Telephone number can't be empty");
		};
		
		Model::Field(InternalPhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(InternalPhoneNumber, "Internal phone number can't be empty");
		};

		Model::Field(ContactName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(ContactName, "Contact name can't be empty");
		};
		Model::Field(OwnerName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(OwnerName, "Owner name can't be empty");
		};

		Model::Field(Email, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Email, "Email can't be empty");
		};

		Model::Field(WebAddress, gettype(string));

		Model::Field(LocalNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(LocalNumber, "Local number can't be empty");
			Rules::PropertyUnique(Name, "A service with that local number already exists", Store);
		};

		Model::Relations(StoreCategory, StoreCategory, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(StoreCategory, "Store category can't be empty");
			Rules::PropertyCollection(StoreCategory, StoreCategory)
			{
				Rules::PropertyNotNull(Category, "Category can't be empty");
			};
		};

		Model::Relations(Service, Service, RelationTypes::UnoAMuchos, false, false)
		{
			Rules::CollectionNonEmpty(Service, "Service can't be empty");
		};
		Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(DataModel, DataModel, RelationTypes::UnoAUno, false, false){};
		Model::Relations(User, User, RelationTypes::UnoAMuchos, false, false){};		
		
	};

	Model::Define(StoreCategory, false){
		Model::Relations(Category, Category, RelationTypes::MuchosAUno, true, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true){};
		
	};

	Model::Define(Table, true){
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name,"Name can't be empty");
		};
		Model::Field(IsStorage, gettype(bool));
		Model::Relations(Fields, Field, RelationTypes::UnoAMuchos, true, true, true){};
		Model::Relations(DataModel, DataModel, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Component, Component, RelationTypes::UnoAUno, true, true, true){};
	};

	Model::Define(User, true){
		Model::Field(UserName, gettype(string))
		{
			Rules::PropertyStringNotEmpty(UserName, "UserName can't be empty");
			Rules::PropertyUnique(UserName, "Duplicated userName", User);

		};
		
		Model::Field(Password, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Password, "Password can't be empty");
		};
		
		Model::Field(Name, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Name, "Name can't be empty");
		};
		
		Model::Field(Surname, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Surname, "Surname can't be empty");
		};
		
		Model::Field(PhoneNumber, gettype(string))
		{
			Rules::PropertyStringNotEmpty(PhoneNumber, "Phone Number can't be empty");
		};
		
		Model::Field(IsUserActive, gettype(bool));
		
		Model::Field(Charge, gettype(string))
		{
			Rules::PropertyStringNotEmpty(Charge, "Charge can't be empty");
		};
		
		Model::Relations(UserGroup, UserGroup, RelationTypes::UnoAMuchos, true, true, true)
		{
			Rules::CollectionNonEmpty(UserGroup, "UserGroup can't be empty");
			Rules::PropertyCollection(UserGroup, UserGroup)
			{
				Rules::PropertyNotNull(Group, "Group can't be empty");
			};
		};

		//Model::Relations(Mall, Mall, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(Store, Store, RelationTypes::MuchosAUno, false, false, false, true){};
		
	};

	Model::Define(UserGroup, false){
		Model::Relations(Group, Group, RelationTypes::MuchosAUno, true, false, false, true)
		{
			Rules::PropertyNotNull(Group, "Group can't be empty");
		};
		Model::Relations(User, User, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Seek stadistical data about services usage
	Model::Define(UserAction, true){
		// An integer that mark the type of the action
		Model::Field(ActionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ActionType, "ActionType can't be negative");
		};
		// The Start time of the action
		Model::Field(Start, gettype(DateTime))
		{
			//Rules::PropertyDateTimeInTheFuture(Start, "Start date can't be in the future");
			Rules::PropertyNotNull(Start, "Start can't be null");
		};
		// The End time of the action
		Model::Field(Stop, gettype(DateTime))
		{
			//Rules::PropertyDateTimeInTheFuture(Stop, "Stop date can't be in the future");
			Rules::PropertyDateTimeLowerThan(Stop, Start, "Stop can't be lower than start");
			Rules::PropertyNotNull(Stop, "Stop can't be null");
		};
		// The Id of the Table on the related data model (when it is applicable)
		Model::Field(IdTable, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdTable, "IdTable can't be negative");
		};
		// The Id of the register on the related data model (when it is applicable)
		Model::Field(IdRegister, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdRegister, "IdRegister can't be negative");
		};
		// The Component that launch the action on the designed Custom Service. This can be 
		// a form, or menuitem
		Model::Field(IdComponent, gettype(int))
		{
			//Rules::PropertyGreaterThanZero(IdComponent, "IdComponent can't be negative");
		};
		// The Id of the service
		Model::Field(IdService, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdService, "IdService can't be negative");
		};
		// The customer that launch the action
		Model::Relations(Customer, Customer, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Seek stadistical data about services usage. Used on client and for interface
	// between Server and Client
	Model::Define(UserActionClientData, true){
		// An integer that mark the type of the action
		Model::Field(ActionType, gettype(int))
		{
			Rules::PropertyGreaterThanZero(ActionType, "ActionType can't be negative");
		};
		// The Start time of the action
		Model::Field(Start, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Start, "Start date can't be in the future");
			Rules::PropertyNotNull(Start, "Start can't be null");
		};
		// The End time of the action
		Model::Field(Stop, gettype(DateTime))
		{
			Rules::PropertyDateTimeInTheFuture(Stop, "Stop date can't be in the future");
			Rules::PropertyDateTimeLowerThan(Stop, Start, "Stop can't be lower than start");
			Rules::PropertyNotNull(Stop, "Stop can't be null");
		};
		// The Id of the Table on the related data model (when it is applicable)
		Model::Field(IdTable, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdTable, "IdTable can't be negative");
		};
		// The Id of the register on the related data model (when it is applicable)
		Model::Field(IdRegister, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdRegister, "IdRegister can't be negative");
		};
		// The Component that launch the action on the designed Custom Service. This can be 
		// a form, or menuitem
		Model::Field(IdComponent, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdComponent, "IdComponent can't be negative");
		};
		// The Id of the service
		Model::Field(IdService, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdService, "IdService can't be negative");
		};
	};

	// Relates registers on tables of datamodels with categories
	Model::Define(RegisterAssociation, true){
		Model::Field(IdRegister, gettype(int))
		{
			Rules::PropertyGreaterThanZero(IdRegister, "IdForm can't be negative");
		};
		Model::Relations(Table, Table, RelationTypes::MuchosAUno, false, false, false, true){};
		Model::Relations(RegisterAssociationCategories, RegisterAssociationCategories, RelationTypes::UnoAMuchos, true, true, true, false){};
	};

	Model::Define(RegisterAssociationCategories, false){
		Model::Relations(Category, Category, RelationTypes::UnoAUno, false, false, false, true){};
		Model::Relations(RegisterAssociation, RegisterAssociation, RelationTypes::MuchosAUno, false, false, false, true){};
	};

	// Bloque custom para el save de Category
	ModelBusiness::CustomSave(Category){	
		if(categoryEntity.IsNew){
			categoryDataAccess.Save(categoryEntity);
			PreferenceDecorator::AddNewPreferencesDueToNewCategory(categoryEntity);
		}
		else{
			categoryDataAccess.Save(categoryEntity);
		}
		return null;
	};	
	// Bloque custom para el delete de Category
	ModelBusiness::CustomDelete(Category){
		// Delete categoryEntity using data access object
		categoryDataAccess.Delete(categoryEntity);
		// Delete related customers' preference
		PreferenceDataAccess^ preferenceDataAccess = new PreferenceDataAccess();
        foreach (PreferenceEntity^ preferenceEntity in preferenceDataAccess.LoadWhere(PreferenceEntity::DBIdCategory, categoryEntity.Id, false, OperatorType::Equal))
		{
			preferenceDataAccess.Delete(preferenceEntity);
		}
		return null;
	};
	// Bloque custom para el save de Customer
	ModelBusiness::CustomSave(Customer){
		if(customerEntity.IsNew){
			customerDataAccess.Save(customerEntity);
			PreferenceDecorator::AddNewPreferencesDueToNewCustomer(customerEntity);
		}
		else{
			customerDataAccess.Save(customerEntity);
		}
		return null;
	};
	// Bloque custom para el save de Category
	ModelBusiness::CustomSave(Service){	
		// Check that the service is not deployed
		if(serviceEntity.Deployed){
			throw new DotNET::System::ServiceModel::FaultException("The service is already deployed. Can not be saved.");
		}
		serviceDataAccess.Save(serviceEntity);
		return null;
	};	
	// Bloque custom delete para el Data Model
	ModelBusiness::CustomDelete(DataModel){
		// Check that the service is not deployed
		if (dataModelEntity.Deployed)
		{
			throw new DotNET::System::ServiceModel::FaultException("The data model is already deployed. Can not be deleted.");
		}
		// Delete dataModelEntity using data access object
		datamodelDataAccess.Delete(dataModelEntity);
		return null;
	};
	// Bloque custom save para el Data Model
	ModelBusiness::CustomSave(DataModel){	
		// Check that the service is not deployed
		if (dataModelEntity.Deployed)
		{
			throw new DotNET::System::ServiceModel::FaultException("The data model is already deployed. Can not be saved.");
		}

		// Check that there isn't related custom services
		if (dataModelEntity.Id > 0)
		{
			DotNET::UtnEmall::Server::DataModel::CustomerServiceDataDataAccess^ customerServiceData = new DotNET::UtnEmall::Server::DataModel::CustomerServiceDataDataAccess();
			// Get all customer services where IdDataModel is the same as us
			int referencedServices = customerServiceData.LoadWhere(DotNET::UtnEmall::Server::EntityModel::CustomerServiceDataEntity::DBIdDataModel, dataModelEntity.Id, false, DotNET::UtnEmall::Server::Base::OperatorType::Equal).Count;
			// If there are customer services it is an error
			if (referencedServices > 0)
			{
				throw new DotNET::System::ServiceModel::FaultException("The data model has related customer services. Can not be saved.");
			}
		}
		
		// Save dataModelEntity using data access object
		datamodelDataAccess.Save(dataModelEntity);
		return null;
	};
}

// Clases externas redefinidas en Meta D++
namespace DotNET::UtnEmall::Server::BusinessLogic{
	extern class PreferenceDecorator{
    public:
		extern static void AddNewPreferencesDueToNewCategory(CategoryEntity*ref category);
        extern static void AddNewPreferencesDueToNewCustomer(CustomerEntity*ref customer);
	}
}
