import "System", "platform=DotNET", "ns=DotNET", "assembly=mscorlib";
using Zoe;
using DotNET::System;
using DotNET::LayerD::ZOECompiler;
using DotNET::LayerD::CodeDOM;
using DotNET::System::Collections;

//Utils::DefaultNetImports();

namespace UtnEmall::Utils
{
	// Clase factory para el modelo de negocio(classEntity) y de datos(DataAccessEntity).
	public factory class Model
	{
		static Hashtable^ clasesBusiness = new Hashtable();
		//ArrayList que almacena los campos de las entityclass.
		static ArrayList^ listaCampos=new ArrayList(); 
		// ArrayList que almacena los tipos de los campos de las entityclass.
		static ArrayList^ listaTipos=new ArrayList(); 
		// ArrayList que almacena las relaciones con la entity actual.
		static ArrayList^ listaRelaciones=new ArrayList(); 
		// ArrayList que almacena las relaciones con la entity actual.
		static ArrayList^ listaRestricciones=new ArrayList(); 
		// nombre de la clase Entity
		static XplIName^ entityClassName = null; 
		//Espacio de nombre para web servicies de entities, opcional
		static string^ entityWebServiceNS = null; 
		// nombre de la clase de Acceso a Datos
		static XplIName^ dataAccessClassName = null; 
		// Tipo de la clase entity actual
		static XplType^ entityType = null; 
		//Tipo de la clase dataAccess actual.
		static XplType^ dataAccessType = null; 
		static XplNamespace^ entityNS = null;
		static XplNamespace^ businessLogicNS = null;
		static bool addPreserveReferenceAttribute;

		static XplType^ connectionType = null;
		static XplType^ transactionType = null;
		static XplType^ commandType = null;
		static XplType^ parameterType = null;
		static bool isMobil = false;
		static bool isIdIdentity = true;
		static int serializationCount;
		static XplExpression^ dataMemberExpression = null;
		static XplExpression^ isMobilExp = null;

		static XplIName^ namespaceEntity = null;
		static XplIName^ namespaceBusiness = null;

		static XplFunctionBody^ BusinessRulesBlock = new XplFunctionBody();
	
	public:
		static XplNode^ SetEntityWSNamespace(string^ wsNamespace){
			entityWebServiceNS = wsNamespace;
			return null;
		}
		static XplNode^ PreserveReferencies(){
			addPreserveReferenceAttribute = true;
			return null;
		}
		static XplNode^ ReinitSerializationCount2(int count){
			return writecode( UtnEmall::Utils::Model::ReinitSerializationCount($count) );
		}
		static XplNode^ ReinitSerializationCount(int count){
			serializationCount = count;
			return null;
		}
		static XplNode^ InsertDataMemberAttribute(bool isMobil, bool isArray){

			string^ attStr = null;
			if(!isMobil){
				attStr = "System.Runtime.Serialization.DataMember( Order = " + serializationCount.ToString() + " )";
			}
			else{
				if(!isArray){
					attStr = "System.Xml.Serialization.XmlElementAttribute( Order = " + serializationCount.ToString() + " )";
				}
				else{
					attStr = "System.Xml.Serialization.XmlArrayAttribute( IsNullable = true, Order = " + serializationCount.ToString() + " )";
				}
			}
			serializationCount++;
			return writecode( Zoe::Attribute::Add($attStr) );
		}
		static XplNode^ DefineMobil(bool mobil){
			connectionType = new XplType();
			transactionType = new XplType();
			commandType = new XplType();
			parameterType = new XplType();
			isMobil = mobil;

			if(mobil)
			{
				connectionType.set_typename("SqlCeConnection");
				transactionType.set_typename("SqlCeTransaction");
				commandType.set_typename("SqlCeCommand");
				parameterType.set_typename("SqlCeParameter");
			}
			else
			{
				connectionType.set_typename("IDbConnection");
				transactionType.set_typename("IDbTransaction");
				commandType.set_typename("IDbCommand");
				parameterType.set_typename("IDbDataParameter");
			}
			return null;
		}
		static XplNode^ DefineIdentity(bool identity){
			isIdIdentity = identity;
			return null;
		}
		static XplNode^ DefineNamespace(iname void defNamespaceEntity){
			namespaceEntity = new XplIName(defNamespaceEntity.Identifier);
			return null;
		}
		static XplNode^ DefineBusinessNamespace(iname void defNamespaceEntity){
			namespaceBusiness = new XplIName(defNamespaceEntity.Identifier);
			return null;
		}
		// Define las clases Entity y DataAccess para cada clase del modelo.
		static XplNode^ Define(iname void modelName, iname void tableName, bool business, block modelData){
			return Define(modelName, tableName, business, false, modelData);
		}
		static XplNode^ Define(iname void modelName, bool business, block modelData){
			return Define(modelName, modelName, business, false, modelData);
		}
		static XplNode^ Define(iname void modelName, bool business, bool addCircularReferenceAttribute, block modelData){
			return Define(modelName, modelName, business, addCircularReferenceAttribute, modelData);
		}
		static XplNode^ Define(iname void modelName, iname void tableName, bool business, bool addCircularReferenceAttribute, block modelData){
			if(business)
			{
				clasesBusiness.Add(modelName.Identifier, "");
			}
			if(namespaceEntity == null)
			{
				if(isMobil)
				{
					namespaceEntity = new XplIName("DotNET::UtnEmall::Client::EntityModel");
				}
				else
				{
					namespaceEntity = new XplIName("DotNET::UtnEmall::Server::EntityModel");
				}
			}
			if(namespaceBusiness == null)
			{
				if(isMobil)
				{
					namespaceBusiness = new XplIName("DotNET::UtnEmall::Client::BusinessLogic");
				}
				else
				{
					namespaceBusiness = new XplIName("DotNET::UtnEmall::Server::BusinessLogic");
				}
			}

			if(businessLogicNS == null){
				businessLogicNS = (XplNamespace^)writecode{
					namespace $namespaceBusiness {	}
				}.Children().FirstNode();
				//Lo inserto en el DocumentBody
				XplNode^ body = context;
				while(body.get_TypeName()!="XplDocumentBody")body = body.get_Parent();
				body.Children().InsertAtEnd(businessLogicNS);
			}

			if(entityNS == null){
				entityNS = (XplNamespace^)writecode{
					namespace $namespaceEntity {	}
				}.Children().FirstNode();
				//Lo inserto en el DocumentBody
				XplNode^ body = context;
				while(body.get_TypeName()!="XplDocumentBody")body = body.get_Parent();
				body.Children().InsertAtEnd(entityNS);
			}

			if(isMobilExp == null)
			{
				if(isMobil)
					isMobilExp = writecode(true);
				else
					isMobilExp = writecode(false);
			}

			if(dataMemberExpression == null)
			{
				if(isMobil)
					dataMemberExpression = writecode( UtnEmall::Utils::Model::InsertDataMemberAttribute( true , false ) );
				else
					dataMemberExpression = writecode( UtnEmall::Utils::Model::InsertDataMemberAttribute( false , false ) );
			}

			XplClass^ clase = null;
			dataAccessClassName = new XplIName( modelName.Identifier + "DataAccess" );
			XplIName^ entityClass = new XplIName(modelName.Identifier + "Entity" );
			//Un identificador para el tipo de diccionario de entidades
			XplIName^ dictInMemoryEntities = new XplIName(modelName.Identifier + "memory");

			//public class $dataAccessClassName implements IDataAccess
			clase = writecode
			{
					 // <summary>
					 //   El <c>$dataAccessClassName$</c> es una clase
					 //   que provee acceso a la base de datos para la tabla correspondiente.
					 // </summary>
					public class $dataAccessClassName
					{
						bool isGlobalTransaction;
						$connectionType^ dbConnection;
						$transactionType^ dbTransaction;
						DataAccessConnection^ dataAccess;

						Dictionary::New( DictionaryOfStringIEntity , gettype( string^ ), gettype( IEntity^) );
						Dictionary::New( dict , gettype( string^ ), gettype(Type^) );
						Dictionary::New( $dictInMemoryEntities , gettype( int ), gettype( $entityClass^ ) );

						$dictInMemoryEntities^ inMemoryEntities;

						static dict^ properties;
						
						static bool dbChecked;

						public:
							// <summary>
							//   Inicializa una nueva instancia de
							//   <c>$dataAccessClassName$</c>.
							//   Chequea si la tabla y los procedimientos almacenados
							//   ya existen en la base de datos, si no, los crea
							//   Establece las propiedades que permite realizar consultas
							//   llamando los metodos LoadWhere.
							// </summary>
							$dataAccessClassName()
							{
								dataAccess = DataAccessConnection::Instance;
								if (!dbChecked)
								{
									DbChecked();
								}

								if(properties==null)
								{
									SetProperties();
								}

								inMemoryEntities = new $dictInMemoryEntities();
							}
						
					}
				};
			//Inserto el modelo dentro de la clase
			context.CurrentNamespace.Children().InsertAtEnd(clase);	
			clases.Add(modelName.Identifier+"DataAccess", clase);

			
			//Inserto el comentario de la clase de entidad
			// context.CurrentNamespace.Children().InsertAtEnd(
			//		writecode{
			//		}.Children().FirstNode()
			// 	);
			
			//Inserto el atributo de serialización de la clase de entidad
			if(isMobil)
			{				
				string^ wsNS = namespaceEntity.Identifier.Replace("::",".");				
				if(wsNS[0]=='D')wsNS=wsNS.Substring(7);
				if(entityWebServiceNS==null){
					wsNS = "System.Xml.Serialization.XmlTypeAttribute(Namespace = \"http://schemas.datacontract.org/2004/07/"+wsNS+"\")";
				}
				else{
					wsNS = "System.Xml.Serialization.XmlTypeAttribute(Namespace = \"http://schemas.datacontract.org/2004/07/"+entityWebServiceNS+"\")";
				}
				entityNS.Children().InsertAtEnd(
					writecode( Zoe::Attribute::Add("System.SerializableAttribute") )
				);
				entityNS.Children().InsertAtEnd(
					writecode( Zoe::Attribute::Add($wsNS) )
				);
			}
			else
			{
				entityNS.Children().InsertAtEnd(
					writecode(Zoe::Attribute::Add("System.Runtime.Serialization.DataContract"))
				);
			}
			entityClassName = new XplIName(modelName.Identifier+"Entity");
			//string^ str = "SuppressMessage(\"Microsoft.Usage\", \"CA2227:CollectionPropertiesShouldBeReadOnly\", Justification = \"We need set for serialization on web services interfaces.\")";
			//Zoe::Attribute::Add($str);
			clase = writecode{
					// <summary>
					//   El <c>$entityClassName$</c> en una clase de entidad
					//   que contiene todos los campos que son insertados y cargados en la base de datos
					//   Esta clase es utilizada por todas las capas superiores.
					// </summary>
					public class $entityClassName implements IEntity
					{
						int id;
						bool changed;
						bool isNew;
						zoe::lang::DateTime timestamp;
						CollectionOfError^ errors;

						UtnEmall::Utils::Model::ReinitSerializationCount(0);
						UtnEmall::Utils::List::NewCollection(CollectionOfError, gettype(Error^));

						public:
							// <summary>
							// Inicializa una nueva instancia de un <c>$entityClassName$</c>.
							// </summary>
							$entityClassName ()
							{
								isNew = true;
								errors = new CollectionOfError();
							}					
							
							// <summary>
							// Obtiene o establece el id de la entidad.
							// <summary>
							$dataMemberExpression;
							int property Id
							{
								get
								{
									return id;
								}
								set
								{
									id = value;
								}
							}

							// <summary>
							// Obtiene o establece si la entidad fue modificada.
							// <summary>
							$dataMemberExpression;
							bool property Changed
							{
								get
								{
									return changed;
								}
								set
								{
									changed = value;
								}
							}

							// <summary>
							// Establece o obtiene si la entidad es nueva.
							// <summary>
							$dataMemberExpression;
							bool property IsNew
							{
								get
								{
									return isNew;
								}
								set
								{
									isNew = value;
								}
							}


							// <summary>
							// Establece o obtiene el timestamp del ultimo acceso.
							// <summary>
							$dataMemberExpression;
							zoe::lang::DateTime property Timestamp
							{
								get
								{
									return timestamp;
								}
								set
								{
									timestamp = value;
								}
							}


							const string^ DBTimestamp = "timestamp";
							// <summary>
							// Coleccion de errores de la entidad.
							// <summary>
							UtnEmall::Utils::Model::InsertDataMemberAttribute( $isMobilExp , true );
							
							CollectionOfError^ property Errors
							{
								get
								{
									return errors;
								}
								set
								{
									errors = value;
								}
							}
					}
				};

			if(addCircularReferenceAttribute){
				modelData.Children().InsertAtEnd(
					writecode( Model::PreserveReferencies() )
					);
			}
			modelData.Children().InsertAtEnd(
				writecode( Model::ProcessModel($modelName, $tableName) )
				);
			
			//Inserto el modelo dentro de la clase
			XplNodeList::CopyNodesAtEnd(modelData.Children(), clase.Children());

			//Agrego el reconteo de propiedades
			clase.Children().InsertAtEnd(
				writecode( UtnEmall::Utils::Model::ReinitSerializationCount2(5) )
				);

			entityNS.Children().InsertAtEnd(clase);

			return null;
		}
		static XplNode^ DefineBusinessLogic(iname void modelName){		
			if(addPreserveReferenceAttribute){
				businessLogicNS.Children().InsertAtEnd(
						writecode(
							ModelBusiness::Define($modelName, true)
							{
								$BusinessRulesBlock;
							}
						)
					);
			}
			else{
				businessLogicNS.Children().InsertAtEnd(
						writecode(
							ModelBusiness::Define($modelName, false)
							{
								$BusinessRulesBlock;
							}
						)
					);
			}
			return null;
		}
		// Define los campos y propiedades de cada entity y agrega cada campo y su tipo
		// a la lista de campos y la lista de tipos de campos
		static exp void Field(iname void fieldName, type fieldType){
			return Field(fieldName, fieldType, null);
		}
		static exp void Field(iname void fieldName, type fieldType, block rulesBlock){
			if(rulesBlock!=null)
			{
				BusinessRulesBlock.Children().InsertAtEnd(
						rulesBlock.Children()
					);
			}

			string^ typeName = fieldType.get_typename();
			XplIName^ internalFieldName = new XplIName("_"+fieldName.Identifier);
			XplClassMembersList^ listaMiembros = null;
						
			switch(fieldType.get_typename())
			{
				case NativeTypes::Boolean:
				case NativeTypes::Float:
				case NativeTypes::Double:
				case NativeTypes::Integer:
					listaMiembros = 
						writecode{%

						private:
							$fieldType $internalFieldName;
						public:
							$dataMemberExpression;
							// <summary>
							// Obtiene o establece los valores para $fieldName$.
							// <summary>
							$fieldType property $fieldName
							{
								get 
								{ 
									return $internalFieldName; 
								} 
								set {
									$internalFieldName = value;
									changed = true;
								}
							}
						%};
					break;
				case "UtnEmall.Utils.Image":
					XplIName^ fieldAsImage = new XplIName(fieldName.Identifier+"AsImage");
					listaMiembros = 
						writecode{%
						private:
							string^ $internalFieldName;
						// <summary>
						// Obtiene o establece el $fieldName.
						// <summary>
						public:
							$dataMemberExpression;
							string^ property $fieldName
							{
								get 
								{ 
									return $internalFieldName; 
								} 
								set 
								{
									$internalFieldName = value;
									changed = true;
								}
							}
						%};
					break;
				case NativeTypes::String:
					listaMiembros = 
						writecode{%
						private:
							$fieldType^ $internalFieldName;
						public:
							$dataMemberExpression;
							// <summary>
							// Obtiene o establece el valor para $fieldName$.
							// <summary>
							$fieldType^ property $fieldName
							{
								get 
								{ 
									return $internalFieldName; 
								} 
								set 
								{
									$internalFieldName = value;
									changed = true;
								}
							}
						%};
					break;
				default:
					listaMiembros = 
						writecode{%
						private:
							$fieldType $internalFieldName;
						public:
							$dataMemberExpression;
							// <summary>
							// Obtiene o establece el valor para $fieldName$.
							// <summary>
							$fieldType property $fieldName
							{
								get 
								{ 
									return $internalFieldName; 
								} 
								set {
									$internalFieldName = value;
									changed = true;
								}
							}
						%};
					break;
			}

			//Inserto los miembros en la clase actual
			XplNodeList::CopyNodesAtEnd(listaMiembros.Children(), context.CurrentClass.Children());
			//Agrego la info del campo al array list 
			listaCampos.Add(fieldName);
			listaTipos.Add(fieldType);

			return null;
		}
		static exp void Relations(iname void fieldName, iname void referencedType, iname void parentName, 
								int relationType, bool recursiveLoad, bool recursiveSave, bool deleteCascade, 
								bool generateRelation, bool loadSubRelations, block rulesBlock)	{
			if(rulesBlock!=null)
			{
				BusinessRulesBlock.Children().InsertAtEnd(
						rulesBlock.Children()
					);
			}

			XplIName^ internalFieldName = new XplIName("_"+fieldName.Identifier);
			XplIName^ internalFieldNameId = new XplIName("_Id"+fieldName.Identifier);
			XplIName^ fieldNameId= new XplIName("Id"+fieldName.Identifier);
			XplType^ entityTypeRelation = new XplType();
			entityTypeRelation.set_typename(referencedType.Identifier+"Entity");

			Relation^ relation = new Relation();
			relation.fieldName = fieldName;
			relation.referencedType = referencedType;
			relation.relationType = relationType;
			relation.parentName = parentName;
			relation.recursiveLoad = recursiveLoad;
			relation.recursiveSave = recursiveSave;
			relation.deleteCascade = deleteCascade;
			relation.generateRelation = generateRelation;
			relation.loadSubRelations = loadSubRelations;

			// Aqui generar los campos para los Id de las relaciones y las propiedades,
			// si es recursiveLoad entonces agregar un campo y propiedad para los elementos relacionados

			XplClassMembersList^ listaMiembros = null;
			//OK, aqui deberia hacer un switch mas grande de acuerdo a cada tipo de campo
			
			//Para los tipos de listas
			XplIName^ listOfTypeName = new XplIName( "CollectionOf" + entityTypeRelation.get_typename() );
			XplType^ listOfType = new XplType();
			listOfType.set_typename( listOfTypeName.Identifier );
			string^ str = "System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Usage\", \"CA2227:CollectionPropertiesShouldBeReadOnly\", Justification = \"We need set for serialization and deserialization web service interfaces.\")";
			if(relationType == RelationTypes::UnoAMuchos)
			{
				listaMiembros = 
					writecode{%
					private:
						UtnEmall::Utils::List::NewCollection( $listOfTypeName , gettype( $entityTypeRelation^ ) );
						$listOfType^ $internalFieldName;
					public:
						
						UtnEmall::Utils::Model::InsertDataMemberAttribute( $isMobilExp , true );
						Zoe::Attribute::Add($str);
						// <summary>
						// Obtiene o establece el valor para $fieldName$.
						// <summary>
						$listOfType^ property $fieldName
						{
							get 
							{
								if($internalFieldName == null)
								{
									$internalFieldName = new $listOfType(); 
								}
								return $internalFieldName; 
							} 
							set
							{
								$internalFieldName = value;
							}
						}
					%};
			}
			
			if(relationType == RelationTypes::UnoAUno)
			{
				listaMiembros = 
					writecode{%
					
					private:
						$entityTypeRelation^ $internalFieldName;
						int $internalFieldNameId;
					public:
						// <summary>
						// Obtiene o establece el valor para $fieldName$.
						// <summary>
						$dataMemberExpression;
						$entityTypeRelation^ property $fieldName
						{
							get 
							{ 
								return $internalFieldName;
							} 
							set 
							{
								$internalFieldName = value;
								// Si el valor proporcionado es null, modifica el id a 0, sino el id del objeto indicado.
								if($internalFieldName != null)
									$fieldNameId = $internalFieldName.Id;
								else
									$fieldNameId = 0;
								changed = true;
							}
						}

						// <summary>
						// Obtiene o establece el Id del $fieldName$.
						// Si $fieldName$ esta establecido devuelve el id del objeto,
						// sino devuelve el id almacenado manualmente.
						// <summary>
						$dataMemberExpression;
						int property $fieldNameId
						{
							get 
							{ 
								if($internalFieldName == null)
								{
									return $internalFieldNameId; 
								}
								else
								{
									return $internalFieldName.Id;
								}
							} 
							set 
							{
								$internalFieldNameId = value;
							}
						}
					%};
					listaCampos.Add(fieldNameId);
					listaTipos.Add( (XplType^)gettype(int) );
			}
			
			if(relationType == RelationTypes::MuchosAMuchos)
			{
			}
				
			if(relationType == RelationTypes::MuchosAUno)
			{
				listaMiembros = 
					writecode{%
					
					private:
						$entityTypeRelation^ $internalFieldName;
						int $internalFieldNameId;
					public:
						// <summary>
						// Establece u obtiene el valor para $fieldName$.
						// <summary>
						$dataMemberExpression;
						$entityTypeRelation^ property $fieldName
						{
							get 
							{ 
								return $internalFieldName;
							} 
							set 
							{
								$internalFieldName = value;
								// Si el valor proporcionado es null, modifica el id a 0, sino el id del objeto indicado.
								if($internalFieldName != null)
									$fieldNameId = $internalFieldName.Id;
								else
									$fieldNameId = 0;
								changed = true;
							}
						}

						// <summary>
						// Obtiene o establece el Id del $fieldName$.
						// Si $fieldName$ esta establecido devuelve el id del objeto,
						// sino devuelve el id almacenado manualmente.
						// <summary>
						$dataMemberExpression;
						int property $fieldNameId
						{
							get
							{
								if($internalFieldName == null)
								{
									return $internalFieldNameId; 
								}
								else
								{
									return $internalFieldName.Id;
								}
							}
							set
							{
								$internalFieldNameId = value;
							}
						}
					%};
					listaCampos.Add(fieldNameId);
					listaTipos.Add( (XplType^)gettype(int));
			}
			//Inserto los miembros en la clase actual
			XplNodeList::CopyNodesAtEnd(listaMiembros.Children(), context.CurrentClass.Children());

			listaRelaciones.Add( relation );
			
			return null;
		}
		static exp void Relations(iname void fieldName, iname void referencedType, int relationType, 
								bool recursiveLoad, bool recursiveSave, block rulesBlock){
			return Relations(fieldName, referencedType, null, relationType, recursiveLoad, recursiveSave,  false, false, true, rulesBlock);
		}
		static exp void Relations(iname void fieldName, iname void referencedType, int relationType, 
								bool recursiveLoad, bool recursiveSave, bool deleteCascade, block rulesBlock){
			return Relations(fieldName, referencedType, null, relationType, recursiveLoad, recursiveSave,  deleteCascade, false, true, rulesBlock);
		}
		static exp void Relations(iname void fieldName, iname void referencedType, int relationType, 
								bool recursiveLoad, bool recursiveSave, bool deleteCascade, bool generateRelation, block rulesBlock){
			return Relations(fieldName, referencedType, null, relationType, recursiveLoad, recursiveSave, deleteCascade, generateRelation, true, rulesBlock);
		}
		// Define las Funciónes para el dataAccessEntity. Las inserta dentro de esta clase.
		static exp void ProcessModel(iname void modelName, iname void tableName){
			dataAccessType = new XplType();
			dataAccessType.set_typename(modelName.Identifier+"DataAccess");
			entityType = new XplType();
			entityType.set_typename(modelName.Identifier+"Entity");
			
			SetConnectionObjects(modelName);
			
			GenerateLoad(modelName,tableName);

			GenerateDBChecked(modelName,tableName);
			GenerateSave(modelName,tableName);

			GenerateDelete(modelName,tableName);
			GenerateCheckDeleteFunctions(modelName, tableName);

			GenerateSetProperties(modelName);

			GenerateLoadAll(modelName,tableName);
			GenerateLoadWhere(modelName,tableName);

			GenerateFunctionRelations(modelName,tableName);
						
			if(clasesBusiness.ContainsKey(modelName.Identifier))
			{
				DefineBusinessLogic(modelName);
			}
						
			BusinessRulesBlock = new XplFunctionBody();

			listaCampos = new ArrayList();
			listaTipos = new ArrayList();
			listaRelaciones = new ArrayList();
			listaRestricciones = new ArrayList();
			addPreserveReferenceAttribute = false;

			return null;
		}
		// Agrega una restriccion a la eliminación de la entidad. 
		// targetTypeName : El nombre de la clase destino a chequear por su existencia.
		// targetFieldName : El nombre del campo en la clase destino a chequear (el valor de este campo se comparará con el Id de la entidad a borrar
		static exp void DeleteRestriction(iname void targetTypeName, iname void targetFieldName, string^ messageToUser){
			DeleteRestriction^ restriction = new DeleteRestriction();
			restriction.referencedType = targetTypeName;
			restriction.fieldName = targetFieldName;
			restriction.messageToUser = messageToUser;
			listaRestricciones.Add(restriction);
			return null;
		}
		// Genera la función para controlar las relaciones al eliminar
		static void GenerateCheckDeleteFunctions(iname void modelName, iname void tableName){

			// Si no hay restricciones, salir
			if(listaRestricciones.Count == 0) return;
			
			XplFunctionBody^ funcBody = new XplFunctionBody();
			XplIName^ mainEntityName = new XplIName(modelName.Identifier + "Entity");

			// Primero se crean las variables del dataaccess
			Hashtable^ added = new Hashtable();
						
			for(DeleteRestriction^ restriction in listaRestricciones){
				// Nombre del tipo de dataaccess
				XplIName^ dataAccessName = new XplIName(restriction.referencedType.Identifier + "DataAccess");
				// Nombre de la variable del dataaccess
				XplIName^ dataAccessVarName = new XplIName( "var" + restriction.referencedType.Identifier + "DataAccess");
				
				if(added[restriction.referencedType.Identifier]==null){
					funcBody.Children().InsertAtEnd(
						writecode{
							$dataAccessName^ $dataAccessVarName = new $dataAccessName();
						}.Children()
					);
					added.Add(restriction.referencedType.Identifier, true);
				}
			}

			for(DeleteRestriction^ restriction in listaRestricciones){
				// Name of entity type
				XplIName^ entityName = new XplIName(restriction.referencedType.Identifier + "Entity");
				// Nombre del tipo de dataaccess
				XplIName^ dataAccessName = new XplIName(restriction.referencedType.Identifier + "DataAccess");
				// Nombre de la variable del dataaccess
				XplIName^ dataAccessVarName = new XplIName( "var" + restriction.referencedType.Identifier + "DataAccess");
				// Name of related field constant identifier on entity
				XplIName^ relatedFieldConstant = new XplIName(restriction.referencedType.Identifier + "Entity::DBId" + restriction.fieldName.Identifier);
				string^ messageString = restriction.messageToUser;
				
				funcBody.Children().InsertAtEnd(
					writecode{						
						if($dataAccessVarName.LoadWhere( $relatedFieldConstant, entity.Id, false, OperatorType::Equal ).Count > 0){
							throw new UtnEmallDataAccessException($messageString);
						}
					}.Children()
				);
			}

			// Create the Function and insert into de DAO class
			GetDataAccessClass( modelName.Identifier ).Children().
				InsertAtEnd(
					writecode{%
						static void CheckForDelete($mainEntityName^ entity){
							$funcBody;
						}
					%}.Children()
				);
		}
		// Genera la Función Load para la cargar una entity particular		
		static void GenerateLoad(iname void modelName, iname void tableName){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ entityStringName = modelName.Identifier;
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			string^ sql = "SELECT " + nameId;
			int timestamp = listaCampos.Count + 1;

			for(int i = 0; i<listaCampos.Count; i++)
			{
				sql += ", " + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
			}

			sql+=", timestamp FROM ["+ tableName.Identifier +"] WHERE " + nameId + " = " +nameIdParameter;

			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			
			fieldsBlock.Children().InsertAtEnd(
					writecode(
						$entity.Id = reader.GetInt32(0)
						)
					);

			XplIName^ propertyName;
			int j = 0;
			for(int i = 0; i<listaCampos.Count; i++)
			{
				j++;
				XplType^ propertyType = (XplType^)listaTipos[i];
				XplIName^ propertyTypeCall = null;
				XplExpression^ read = null;
				bool datetime= false;
				bool isString = false;
				
				switch(propertyType.get_typename())
				{
					case NativeTypes::Boolean:
						read = writecode(reader.GetBoolean($j));
						break;
					case NativeTypes::Float:
						read = writecode(reader.GetFloat($j));
						break;
					case NativeTypes::Double:
						read = writecode(Convert::ToDouble(reader.GetDecimal($j)));
						break;
					case NativeTypes::Integer:
						read = writecode(reader.GetInt32($j));
						break;
					case NativeTypes::String:
						propertyName = (XplIName^)listaCampos[i];
						XplNodeList::CopyNodesAtEnd( 
							writecode
							{
								if(!reader.IsDBNull($j))
								{
									$entity.$propertyName = reader.GetString($j);
								}
							}.Children(), fieldsBlock.Children() );

						isString = true;
						break;
					case "UtnEmall.Utils.Image":
						propertyName = (XplIName^)listaCampos[i];
						XplNodeList::CopyNodesAtEnd( 
							writecode
							{
								if (!reader.IsDBNull($j))
								{
									byte[] bytes = (byte[])reader[$j];
									$entity.$propertyName = DotNET::System::Convert::ToBase64String(bytes);
								}
							}.Children(), fieldsBlock.Children() );

						isString = true;
						break;
					default:
						read = writecode(reader.GetDateTime($j));
						break;
				}
				
				if(!isString)
				{
					propertyName = (XplIName^)listaCampos[i];
						fieldsBlock.Children().InsertAtEnd(
							writecode(
								$entity.$propertyName = $read
								)
							);
				}
			}

			XplFunctionBody^ fieldsBlockRelations = new XplFunctionBody();
			for(int i = 0; i < listaRelaciones.Count; i++)
			{
				Relation^ relation = (Relation^)listaRelaciones[i];
				XplIName^ functionName = new XplIName("LoadRelation" + relation.fieldName.Identifier);

				if(relation.recursiveLoad)
				{
					fieldsBlockRelations.Children().InsertAtEnd(
					writecode(
							$functionName($entity, scope)
						)
					);
				}
			}



			XplClassMembersList^ loadFunction = writecode{%
				public:
				// <summary>
				// Función para cargar un $entityType$ desde la base de datos. 
				// </summary>
				// <param name="id">El id del registro a cargar</param>
				// <param name="loadRelation">Si es true carga las relaciones</param>
				// <param name="scope">Estructura interna usada para evitar la referencia circular, debe ser proveida si es llamada desde otro data access</param>
				// <returns>La instancia de la entidad</returns>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre mientras se accede a la base de datos
				// </exception>
				$entityType^ Load(int id, bool loadRelation, DictionaryOfStringIEntity^ scope)
				{
					// Crea una clave para el objeto de scope interno
					string^ scopeKey = id.ToString(DotNET::System::Globalization::NumberFormatInfo::InvariantInfo) + $entityStringName;
					if (scope != null)
					{
						// Si el scope contiene el objeto, este ya fue cargado
						// retorna el objeto situado en el scope para evitar referencias circulares
						if (scope.ContainsKey(scopeKey))
						{
							return ($entityType^)scope[scopeKey];
						}
					}
					else
					{
						// Si no existe un scope, crear uno
						scope = new DictionaryOfStringIEntity();
					}

					$entityType^ $entity = null;
					// Chequear si la entidad fue ya cargada por el data access actual
					// y retornar si fue ya cargada
					if(inMemoryEntities.ContainsKey(id))
					{
						$entity = inMemoryEntities[id];
						// Agregar el objeto actual al scope
						scope.Add(scopeKey, $entity);
					}
					else
					{
						bool closeConnection = false;
						try
						{						
							// Abrir una nueva conexión si no es una transaccion
							if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
							{
								closeConnection = true;
								dbConnection = dataAccess.GetNewConnection();
								dbConnection.Open();
							}
							
							string^ cmdText = $sql;
							// Crea el command
							$commandType^ sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
							// Crear el parametro id para la consulta
							$parameterType^ parameter = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
							parameter.Value = id;
							sqlCommand.Parameters.Add(parameter);

							// Usar el datareader para cargar desde la base de datos
							IDataReader reader = sqlCommand.ExecuteReader();
							$entity = new $entityType();

							if (reader.Read())
							{
								// Cargar las filas de la entidad
								$fieldsBlock;

								// Agregar el objeto actual al scope
								scope.Add(scopeKey, $entity);
								// Agregar el objeto a la cahce de entidades cargadas
								inMemoryEntities.Add($entity.Id, $entity);
								
								// Lee el timestamp y establece las propiedades nuevo y cambiado
								$entity.Timestamp = reader.GetDateTime($timestamp);
								$entity.IsNew = false;
								$entity.Changed = false;

								// Cerrar el Reader
								reader.Close();
								// Carga los objetos relacionadoss if required
								if(loadRelation)
								$fieldsBlockRelations;
							}
							else
							{
								reader.Close();
							}
						}
						catch(DbException^ dbException)
						{
							// Relanza la excepcion como una excepcion personalizada
							throw new UtnEmallDataAccessException(dbException.Message, dbException);
						}
						finally
						{
							// Cierra la conexión si fue creada dentro de la Función
							if(closeConnection)
							{
								dbConnection.Close();
							}
						}
					}
					// Retorna la entidad cargada
					return $entity;
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null)
				{
					XplNodeList::CopyNodesAtEnd(loadFunction.Children(), target.Children());
				}


				XplClassMembersList^ loadFunctionOneParameter = writecode{%
				public:
					// <summary>
					// Función para cargar un $entityType$ desde la base de datos 
					// </summary>
					// <param name="id">El id del registro a cargar</param>
					// <returns>La instancia de la entidad</returns>
					// <exception cref="UtnEmallDataAccessException">
					// Si una DbException ocurre mientras se accede a la base de datos
					// </exception>
					$entityType^ Load(int id)
					{
						return Load(id, true, null);
					}

					// <summary>
					// Función para cargar un $entityType$ desde la base de datos 
					// </summary>
					// <param name="id">El id del registro a cargar</param>
					// <param name="loadRelation">Si es true carga la relacion</param>
					// <returns>La instancia de la entidad</returns>
					// <exception cref="UtnEmallDataAccessException">
					// Si una DbException ocurre mientras se accede a la base de datos
					// </exception>
					$entityType^ Load(int id, bool loadRelations)
					{
						return Load(id, loadRelations, null);
					}

					// <summary>
					// Función para cargar un $entityType$ desde la base de datos 
					// </summary>
					// <param name="id">El id del registro a cargar</param>
					// <param name="scope">Estructura interna usada para evitar la referencia circular, debe ser proveida si es llamada desde otro data access</param>
					// <returns>La instancia de la entidad</returns>
					// <exception cref="UtnEmallDataAccessException">
					// Si una DbException ocurre mientras se accede a la base de datos
					// </exception>
					$entityType^ Load(int id, DictionaryOfStringIEntity^ scope)
					{
						return Load(id, true, scope);
					}
				%};

				target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadFunctionOneParameter.Children(), target.Children());
				}

		}
		// Genera la Función LoadWhere para cargar todas las entitys correspondientes
		static void GenerateLoadWhere(iname void modelName, iname void tableName){
			XplIName^ entityList = new XplIName(ToLowerCamelCase(modelName.Identifier)+"List");
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			string^ sql = "SELECT " + nameId;

			int timestamp = listaCampos.Count + 1;

			for(int i = 0; i<listaCampos.Count; i++)
			{
				sql += ", " + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
			}

			sql+=", timestamp FROM ["+ tableName.Identifier + "]";

			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			
			fieldsBlock.Children().InsertAtEnd(
					writecode(
						$entity.Id = reader.GetInt32(0)
						)
					);

			XplIName^ propertyName;
			int j = 0;
			for(int i = 0; i<listaCampos.Count; i++)
			{
				j++;
				XplType^ propertyType = (XplType^)listaTipos[i];
				XplIName^ propertyTypeCall = null;
				XplExpression^ read = null;
				bool datetime= false;
				bool isString = false;
				switch(propertyType.get_typename())
				{
					case NativeTypes::Boolean:
						read = writecode(reader.GetBoolean($j));
						break;
					case NativeTypes::Float:
						read = writecode(reader.GetFloat($j));
						break;
					case NativeTypes::Double:
						read = writecode(Convert::ToDouble(reader.GetDecimal($j)));
						break;
					case NativeTypes::Integer:
						read = writecode(reader.GetInt32($j));
						break;
					case NativeTypes::String:
						propertyName = (XplIName^)listaCampos[i];
						XplNodeList::CopyNodesAtEnd( writecode{
								if(!reader.IsDBNull($j))
								{
									$entity.$propertyName = reader.GetString($j);
								}
						}.Children(), fieldsBlock.Children());
						isString = true;
						break;
					default:
						read = writecode(reader.GetDateTime($j));
						break;
				}

				if(!isString)
				{
					propertyName = (XplIName^)listaCampos[i];
						fieldsBlock.Children().InsertAtEnd(
							writecode(
								$entity.$propertyName = $read
								)
							);
				}
			}

			XplFunctionBody^ fieldsBlockRelations = new XplFunctionBody();
			for(int i = 0; i < listaRelaciones.Count; i++)
			{
				Relation^ relation = (Relation^)listaRelaciones[i];
				XplIName^ functionName = new XplIName("LoadRelation" + relation.fieldName.Identifier);

				if(relation.recursiveLoad)
				{
					fieldsBlockRelations.Children().InsertAtEnd(
					writecode(
							$functionName($entity)
						)
					);
				}
			}

			//Tipo para lista
			XplType^ listOfType = new XplType();
			listOfType.set_typename( "CollectionOf" + entityType.get_typename() );

			XplClassMembersList^ loadWhereFunction = writecode{%
				public:
					UtnEmall::Utils::List::New( ListInt, gettype(int) );

					// <summary>
					// Función para cargar un $entityType$ desde la base de datos 
					// </summary>
					// <param name="propertyName">Un string con el nombre del campo o una constante de la clase que representa ese campo</param>
					// <param name="expValue">El valor que será insertado en la clausula where</param>
					// <param name="loadRelation">Si es true carga la relacion</param>
					// <returns>Una lista que contiene todas las entidades que concuerdan con la clausula where</returns>
					// <exception cref="ArgumentNullException">
					// Si <paramref name="propertyName"/> es null or vacio.
					// Si <paramref name="propertyName"/> no es una propiedad de la clase $entityType$.
					// Si <paramref name="expValue"/> es null.
					// </exception>
					// <exception cref="UtnEmallDataAccessException">
					// Si una DbException ocurre cuando se accede a la base de datos
					// </exception>
					$listOfType^ LoadWhere(string^ propertyName, object^ expValue, bool loadRelation, OperatorType operatorType)
					{
						if(DotNET::System::String::IsNullOrEmpty(propertyName) ||  expValue==null)
						{
							throw new ArgumentException("The argument can not be null or be empty", "propertyName");
						}						
						if(!properties.ContainsKey(propertyName))
						{
							throw new ArgumentException("The property " + propertyName + " is not a property of this entity", "propertyName");
						}

						$listOfType^ $entityList;
						
						bool closeConnection = false;
						try
						{
							// Abrir una nueva conexión con la base de datos si es necesario
							if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
							{
								closeConnection = true;
								dbConnection = dataAccess.GetNewConnection();
								dbConnection.Open();
							}
		
							string^ op = DataAccessConnection::GetOperatorString(operatorType);

							// Construir la consulta
							string^ cmdText = $sql + " WHERE " + propertyName + " " + op + " @expValue";
							// Crea el command
							$commandType^ sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
							
							// Agrega los parametros al command
							$parameterType^ parameter = dataAccess.GetNewDataParameter();
							parameter.ParameterName = "@expValue";
							DotNET::System::Type^ parameterType = properties[propertyName];
							parameter.DbType = DataAccessConnection::GetParameterDBType(parameterType);	
							
							parameter.Value = expValue;
							sqlCommand.Parameters.Add(parameter);

							// Crea un datareader
							IDataReader^ reader = sqlCommand.ExecuteReader();
							$entityList = new $listOfType();
							$entityType^ $entity;
							ListInt listId = new ListInt();

							// Agrega los id a una lista de ids
							while (reader.Read())
							{
								listId.Add(reader.GetInt32(0));
							}

							// Cerrar el Reader
							reader.Close();

							// Carga las entidades
							foreach(int id in listId)
							{
								$entity = Load( id, loadRelation, null);
								$entityList.Add($entity);
							}
						}
						catch(DbException^ dbException)
						{
							// Relanza la excepcion como una excepcion personalizada
							throw new UtnEmallDataAccessException(dbException.Message, dbException);
						}
						finally
						{
							// Cierra la conexión si fue abierta dentro de la Función
							if(closeConnection)
							{
								dbConnection.Close();
							}
						}

						return $entityList;
					}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadWhereFunction.Children(), target.Children());
				}
		}
		// Genera la Función LoadAll para cargar todas las entitys correspondientes
		static void GenerateLoadAll(iname void modelName, iname void tableName){
			XplIName^ entityList = new XplIName(ToLowerCamelCase(modelName.Identifier)+"List");
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			string^ sql = "SELECT " + nameId;

			// for(int i = 0; i<listaCampos.Count; i++)
			// {
			//	sql += ", " + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
			// }

			// sql+=", timestamp FROM ["+ tableName.Identifier + "]";
			
			sql+=" FROM ["+ tableName.Identifier + "]";

			int timestamp = listaCampos.Count + 1;

			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			
			fieldsBlock.Children().InsertAtEnd(
					writecode(
						$entity.Id = reader.GetInt32(0)
						)
					);

			XplIName^ propertyName;
			int j = 0;
			for(int i = 0; i<listaCampos.Count; i++)
			{
				j++;
				XplType^ propertyType = (XplType^)listaTipos[i];
				XplIName^ propertyTypeCall = null;
				XplExpression^ read = null;
				bool datetime= false;
				bool isString = false;
				switch(propertyType.get_typename())
				{
					case NativeTypes::Boolean:
						read = writecode(reader.GetBoolean($j));
						break;
					case NativeTypes::Float:
						read = writecode(reader.GetFloat($j));
						break;
					case NativeTypes::Double:
						read = writecode(Convert::ToDouble(reader.GetDecimal($j)));
						break;
					case NativeTypes::Integer:
						read = writecode(reader.GetInt32($j));
						break;
					case NativeTypes::String:
						propertyName = (XplIName^)listaCampos[i];
						XplNodeList::CopyNodesAtEnd( writecode{
								if(!reader.IsDBNull($j))
								{
									$entity.$propertyName = reader.GetString($j);
								}
						}.Children(), fieldsBlock.Children());
						isString = true;
						break;
					default:
						read = writecode(reader.GetDateTime($j));
						break;
				}

				if(!isString)
				{
					propertyName = (XplIName^)listaCampos[i];
						fieldsBlock.Children().InsertAtEnd(
							writecode(
								$entity.$propertyName = $read
								)
							);
				}
			}

			XplFunctionBody^ fieldsBlockRelations = new XplFunctionBody();
			for(int i = 0; i < listaRelaciones.Count; i++)
			{
				Relation^ relation = (Relation^)listaRelaciones[i];
				XplIName^ functionName = new XplIName("LoadRelation" + relation.fieldName.Identifier);

				if(relation.recursiveLoad)
				{
					fieldsBlockRelations.Children().InsertAtEnd(
					writecode(
							$functionName($entity)
						)
					);
				}
			}

			//Tipo para lista
			XplIName^ listOfTypeName = new XplIName("CollectionOf" + entityType.get_typename());			
			XplType^ listOfType = new XplType();
			listOfType.set_typename( listOfTypeName.Identifier );

			XplClassMembersList^ loadAllFunction = writecode{%
				public:
					UtnEmall::Utils::List::NewCollection( $listOfTypeName, gettype($entityType^) );

					// <summary>
					// Función que carga todos los $entityType$ desde la base de datos 
					// </summary>
					// <param name="loadRelation">Si es true carga la relacion</param>
					// <returns>Una lista con todas las entidades</returns>
					// <exception cref="UtnEmallDataAccessException">
					// Si una DbException ocurre mientras se accede a la base de datos
					// </exception>
					$listOfType^ LoadAll(bool loadRelation)
					{
						$listOfType^ $entityList = new $listOfType();;

						bool closeConnection = false;
						try
						{
							// Abrir una nueva conexión de ser necesario
							if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
							{
								closeConnection = true;
								dbConnection = dataAccess.GetNewConnection();
								dbConnection.Open();
							}
						
							// Construir la consulta
							string^ cmdText = $sql;
							$commandType^ sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
							
							// Crea un datareader
							IDataReader^ reader = sqlCommand.ExecuteReader();
							
							$entityType^ $entity;
							
							// Lee los ids y los inserta en una lista
							ListInt listId = new ListInt();
							while (reader.Read())
							{
								listId.Add(reader.GetInt32(0));
							}
							// Cierra el DataReader
							reader.Close();
							
							// Crea un scope
							DictionaryOfStringIEntity^ scope = new DictionaryOfStringIEntity();
							
							// Carga las entidades y las agrega a la lista a retornar
							foreach(int id in listId)
							{
								$entity = Load( id, loadRelation, scope);
								$entityList.Add($entity);
							}
						}
						catch(DbException^ dbException)
						{
							// Relanza la excepcion como una excepcion personalizada
							throw new UtnEmallDataAccessException(dbException.Message, dbException);
						}
						finally
						{
							// Cierra la conexión
							if(closeConnection)
							{
								dbConnection.Close();
							}
						}
						// Retorna la entidad cargada
						return $entityList;
					}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadAllFunction.Children(), target.Children());
				}
		}
		// Genera la Función SaveEntity para guardar una entity
		static void GenerateSave(iname void modelName, iname void tableName){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ entityStringName = modelName.Identifier;
			string^ sqlSave = "Save" + tableName.Identifier;
			string^ sqlUpdate = "Update" + tableName.Identifier;
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			string^ tableNameString = tableName.Identifier;
			XplFunctionBody^ fieldsBlockCommandType = new XplFunctionBody();
			XplFunctionBody^ executeBlock = new XplFunctionBody();

			XplFunctionBody^ parameterIdentityBlock = null;

			if(!isIdIdentity)
			{
				parameterIdentityBlock = writecode{
					if(!isUpdate && $entity.Id == 0)
					{
						$entity.Id = DataAccessConnection::GetNextId($nameId,$tableNameString, dbConnection, dbTransaction);
					}
					parameter = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
					parameter.Value = $entity.Id;
					sqlCommand.Parameters.Add(parameter);
				};
			}
			else
			{
				parameterIdentityBlock = writecode{
					if(isUpdate)
					{
						parameter = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
						parameter.Value = $entity.Id;
						sqlCommand.Parameters.Add(parameter);
					}
				};
			}

			if(isMobil)
			{
				sqlSave = "INSERT INTO [" + tableName.Identifier + "] (";
				string^ sqlSaveValues = ") VALUES(";
				sqlUpdate  = "UPDATE [" + tableName.Identifier + "] SET ";
				
				if(!isIdIdentity){
					// Add the id to the sqlSave and sqlSaveValues
					sqlSave += nameId + ", ";
					sqlSaveValues += " @" + nameId + ", ";

					executeBlock.Children().InsertAtEnd(
						writecode( sqlCommand.ExecuteNonQuery() )
					);
				}
				else{
					executeBlock = writecode{
						sqlCommand.ExecuteNonQuery();
						if(!isUpdate){
							sqlCommand = dataAccess.GetNewCommand("SELECT @@IDENTITY;", dbConnection, dbTransaction);
							$entity.Id = Convert::ToInt32( sqlCommand.ExecuteScalar() , DotNET::System::Globalization::NumberFormatInfo::InvariantInfo );
						}
					};
				}

				for(int i = 0; i<listaCampos.Count; i++)
				{
					if(i==0)
					{
						sqlSave += ((XplIName^)listaCampos[i]).Identifier.ToUpper();
						sqlSaveValues += " @" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
						sqlUpdate += "" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier) + " = @" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
					}
					else
					{
						sqlSave += ", " + ((XplIName^)listaCampos[i]).Identifier.ToUpper();
						sqlSaveValues += ",@" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
						sqlUpdate += ", " + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier) + " = @" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
					}
			    }
				sqlSave += ", [TIMESTAMP] ";
	            sqlSaveValues += ", GETDATE()); ";
				sqlSave = sqlSave + sqlSaveValues;

		        sqlUpdate += " , timestamp=GETDATE() WHERE " + nameId + " = @" + nameId;
			}
			else
			{
				fieldsBlockCommandType.Children().InsertAtEnd(
					writecode(
						sqlCommand.CommandType = CommandType::StoredProcedure
						)
					);

				if(isIdIdentity)
				{
					executeBlock = writecode{
						if(isUpdate)
						{
							sqlCommand.ExecuteNonQuery();
						}
						else
						{
							$parameterType^ parameterIdOutput = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
							parameterIdOutput.Direction = ParameterDirection::ReturnValue;
							sqlCommand.Parameters.Add(parameterIdOutput);

							sqlCommand.ExecuteNonQuery();						
							$entity.Id = Convert::ToInt32(parameterIdOutput.Value, DotNET::System::Globalization::NumberFormatInfo::InvariantInfo);
						}
					};
				}
				else
				{
					executeBlock.Children().InsertAtEnd(
						writecode( sqlCommand.ExecuteNonQuery() )
					);
				}
			}
			
			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			
			for(int i = 0; i<listaCampos.Count; i++)
			{
				XplType^ propertyType = (XplType^)listaTipos[i];
				XplIName^ propertyTypeCall = null;
				XplIName^ imageAsChar = new XplIName("imageAsChar"+i);
				XplIName^ imageAsBytes = new XplIName("imageAsBytes"+i);
				bool isString = false;
				bool isImage = false;
				
				switch(propertyType.get_typename())
				{
					case NativeTypes::Boolean:
						propertyTypeCall = new XplIName("DbType::Boolean");
						break;
					case NativeTypes::Float:
						propertyTypeCall = new XplIName("DbType::Decimal");
						break;
					case NativeTypes::Double:
						propertyTypeCall = new XplIName("DbType::Decimal");
						break;
					case NativeTypes::Integer:
						propertyTypeCall = new XplIName("DbType::Int32");
						break;
					case NativeTypes::String:
						propertyTypeCall = new XplIName("DbType::String");
						isString = true;
						break;
					case "UtnEmall.Utils.Image":
						propertyTypeCall = new XplIName("DbType::Object");
						isImage = true;
						break;
					default:
						propertyTypeCall = new XplIName("DbType::DateTime");
						break;
				}
								
				XplIName^ propertyName = (XplIName^)listaCampos[i];
				//XplIName^ propertyNameRelation = new XplIName(propertyName.Identifier.Substring(2));
				string^ propertyStringName = "@" + ToLowerCamelCase(propertyName.Identifier);
				
				XplNodeList::CopyNodesAtEnd( writecode{
						parameter = dataAccess.GetNewDataParameter($propertyStringName, $propertyTypeCall);
				}.Children(), fieldsBlock.Children());

								
				if(isString)
				{
					XplNodeList::CopyNodesAtEnd( writecode
					{
						parameter.Value = $entity.$propertyName;
						if(DotNET::System::String::IsNullOrEmpty($entity.$propertyName))
						{
							parameter.Value = DotNET::System::DBNull::Value;
						}
						sqlCommand.Parameters.Add(parameter);
					}.Children(), fieldsBlock.Children());
				}
				else if(isImage){
						XplNodeList::CopyNodesAtEnd( writecode{
							char[] $imageAsChar = $entity.$propertyName.ToCharArray();
							byte[] $imageAsBytes = Convert::FromBase64CharArray($imageAsChar, 0, (int)$imageAsChar.Length);
							parameter.Value = $imageAsBytes;
							sqlCommand.Parameters.Add(parameter);
						}.Children(), fieldsBlock.Children());
				}
				else{
					XplNodeList::CopyNodesAtEnd( 
						writecode{
							parameter.Value = $entity.$propertyName;
							sqlCommand.Parameters.Add(parameter);
						}.Children(), fieldsBlock.Children());
				}
			}

			bool update = false;

			XplFunctionBody^ fieldsBlockRelations = new XplFunctionBody();
			XplFunctionBody^ entityTemp = new XplFunctionBody();
			XplFunctionBody^ fieldsBlockRelationsToDelete = new XplFunctionBody();
			XplFunctionBody^ fieldsBlockRelationsCollections = new XplFunctionBody();
			for(int i = 0; i < listaRelaciones.Count; i++)
			{				
				Relation^ relation = (Relation^)listaRelaciones[i];
				if( !(relation.recursiveLoad && relation.recursiveSave))
				{
					continue;
				}

				XplType^ dataAccessRelation = new XplType();
				dataAccessRelation.set_typename(relation.referencedType.Identifier+"DataAccess");
				XplIName^ propertyNameRelation = relation.fieldName;
				XplIName^ idPropertyNameRelation = new XplIName("Id" + propertyNameRelation.Identifier);

				if(relation.relationType == RelationTypes::UnoAMuchos)
				{					
					XplIName^ functionName = new XplIName("Save"+relation.referencedType.Identifier+"Collection");

					XplNodeList::CopyNodesAtEnd( writecode{
						if ( $entity.$propertyNameRelation != null )
						{
							this.$functionName((new $dataAccessRelation()),$entity, $entity.$propertyNameRelation, ($entity.IsNew), scope);
						}
					}.Children(), fieldsBlockRelationsCollections.Children());
				}
				else
				{
					XplIName^ varDataAccess = new XplIName(ToLowerCamelCase(relation.referencedType.Identifier)+"DataAccess");
					XplNodeList::CopyNodesAtEnd( writecode{
						if ( $entity.$propertyNameRelation != null )
						{
							$dataAccessRelation $varDataAccess= new $dataAccessRelation();
							$varDataAccess.SetConnectionObjects(dbConnection, dbTransaction);
							$varDataAccess.Save($entity.$propertyNameRelation, scope);
						}
					}.Children(), fieldsBlockRelations.Children());

					if(relation.relationType == RelationTypes::UnoAUno && relation.recursiveSave)
					{
						XplIName^ classNameLoadRelation = new XplIName("LoadRelation" + relation.fieldName.Identifier);
						XplIName^ entity2 = new XplIName(ToLowerCamelCase(modelName.Identifier) + "Temp" + i);

						XplNodeList::CopyNodesAtEnd( writecode{
								$entityType^ $entity2 = new $entityType();
								$entity2.Id = $entity.Id;
								$classNameLoadRelation($entity2, scope);
								if($entity2.$propertyNameRelation != null && $entity2.$idPropertyNameRelation != $entity.$idPropertyNameRelation)
								{
									$dataAccessRelation $varDataAccess= new $dataAccessRelation();
									$varDataAccess.SetConnectionObjects(dbConnection, dbTransaction);
									$varDataAccess.Delete($entity2.$propertyNameRelation, scope);
								}
							
						}.Children(), fieldsBlockRelationsToDelete.Children());
					}
					update = true;
				}
			}
			
			XplFunctionBody^ fieldsBlockUpdate = new XplFunctionBody();
			if(update)
			{
				fieldsBlockUpdate.Children().InsertAtEnd(
						writecode( Update($entity) )
					);
			}

			XplClassMembersList^ saveFunction = writecode{%				
				private:
				void FillSaveParameters($entityType^ $entity, $commandType^ sqlCommand){
					$parameterType^ parameter;
					$fieldsBlock;
				}
				
				public:
				// <summary>
				// Función que guarda un $entityType$ en la base de datos. 
				// </summary>
				// <param name="$entity$">$entityType$ a guardar</param>
				// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void Save($entityType^ $entity){
					Save($entity, null);
				}
				// <summary>
				// Función que guarda un $entityType$ en la base de datos. 
				// </summary>
				// <param name="$entity$">$entityType$ a guardar</param>
				// <param name="scope">Estructura interna para evitar problemas con referencias circulares</param>
				// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void Save($entityType^ $entity, DictionaryOfStringIEntity^ scope)
				{
					if($entity == null)
					{
						throw new ArgumentException("The argument can't be null");
					}
					
					// Crear una clave unica para identificar el objeto dentro del scope interno
					string^ scopeKey = $entity.Id.ToString(DotNET::System::Globalization::NumberFormatInfo::InvariantInfo) + $entityStringName;
					if (scope != null)
					{
						// Si se encuentra dentro del scope lo retornamos
						if (scope.ContainsKey(scopeKey))
						{
							return;
						}
					}
					else
					{
						// Crea un nuevo scope si este no fue enviado
						scope = new DictionaryOfStringIEntity();
					}
										
					try
					{
						// Crea una nueva conexion y una nueva transaccion si no hay una a nivel superior
						if (!(isGlobalTransaction))
						{
							dbConnection = dataAccess.GetNewConnection();
							dbConnection.Open();
							dbTransaction = dbConnection.BeginTransaction();
						}

						string^ commandName = "";
						bool isUpdate = false;
						// Verifica si se debe hacer una actualización o una inserción
						if($entity.IsNew || !DataAccessConnection::ExistsEntity($entity.Id, $tableNameString, $nameId, dbConnection, dbTransaction) ) 
						{
							commandName = $sqlSave;
						}
						else
						{
							isUpdate = true;
							commandName = $sqlUpdate;
							$entityTemp;
							$fieldsBlockRelationsToDelete;
						}

						// Se crea un command
						$commandType^ sqlCommand = dataAccess.GetNewCommand(commandName, dbConnection, dbTransaction);
						$fieldsBlockCommandType;
						
						// Agregar los parametros del command .
						$parameterType^ parameter;
						
						$parameterIdentityBlock;

						FillSaveParameters($entity, sqlCommand);
						
						// Ejecutar el command
						$executeBlock;

						scopeKey = $entity.Id.ToString(DotNET::System::Globalization::NumberFormatInfo::InvariantInfo) + $entityStringName;
						// Agregar la entidad al scope actual
						scope.Add(scopeKey, $entity);

						// Guarda las colecciones de objetos relacionados.
						$fieldsBlockRelationsCollections;

						// Guardar objetos relacionados con la entidad actual 
						$fieldsBlockRelations;
						
						// Actualizar
						$fieldsBlockUpdate;
						
						// Cierra la conexión si fue abierta en la función
						if (!isGlobalTransaction)
		                {
				            dbTransaction.Commit();
						}
						// Actualizar los campos new y changed
						$entity.IsNew = false;
						$entity.Changed = false;					
					}
					catch(DbException^ dbException)
					{
						// Anula la transaccion
						if (!isGlobalTransaction)
						{
							dbTransaction.Rollback();
						}
						// Relanza una excepcion personalizada
						throw new UtnEmallDataAccessException(dbException.Message, dbException);
					}
					finally
					{
						// Cierra la conexión si fue inicializada
						if (!isGlobalTransaction)
						{
							dbConnection.Close();
							dbConnection = null;
							dbTransaction = null;
						}
					}
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(saveFunction.Children(), target.Children());
				}
		}
		static void GenerateUpdate(iname void modelName, iname void tableName){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ sqlUpdate = "Update" + tableName.Identifier;
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			
			XplFunctionBody^ fieldsBlockCommandType = new XplFunctionBody();

			if(isMobil)
			{
				sqlUpdate  = "UPDATE [" + tableName.Identifier + "] SET ";
				for(int i = 0; i<listaCampos.Count; i++)
				{
					if(i==0)
					{
						sqlUpdate += "" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier) + " = @" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
					}
					else
					{
						sqlUpdate += ", " + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier) + " = @" + ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
					}
			    }
		        sqlUpdate += " , timestamp=GETDATE() WHERE " + nameId + " = @" + nameId;
			}
			else
			{
				fieldsBlockCommandType.Children().InsertAtEnd(
					writecode(
						sqlCommand.CommandType = CommandType::StoredProcedure
						)
					);
			}
			
			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			
			for(int i = 0; i<listaCampos.Count; i++)
			{
				XplType^ propertyType = (XplType^)listaTipos[i];
				XplIName^ propertyTypeCall = null;
				bool isString = false;
		
				switch(propertyType.get_typename())
				{
					case NativeTypes::Boolean:
						propertyTypeCall = new XplIName("DbType::Boolean");
						break;
					case NativeTypes::Float:
						propertyTypeCall = new XplIName("DbType::Decimal");
						break;
					case NativeTypes::Double:
						propertyTypeCall = new XplIName("DbType::Decimal");
						break;
					case NativeTypes::Integer:
						propertyTypeCall = new XplIName("DbType::Int32");
						break;
					case NativeTypes::String:
						propertyTypeCall = new XplIName("DbType::String");
						isString = true;
						break;
					case "UtnEmall.Utils.Image":
						propertyTypeCall = new XplIName("DbType::Object");
						break;
					default:
						propertyTypeCall = new XplIName("DbType::DateTime");
						break;
				}

				XplIName^ propertyName = (XplIName^)listaCampos[i];
				//XplIName^ propertyNameRelation = new XplIName(propertyName.Identifier.Substring(2));
				string^ propertyStringName = "@" + ToLowerCamelCase(propertyName.Identifier);
				
				XplNodeList::CopyNodesAtEnd( writecode{
						parameter = dataAccess.GetNewDataParameter($propertyStringName, $propertyTypeCall);
				}.Children(), fieldsBlock.Children());
								
				if(isString)
				{
					XplNodeList::CopyNodesAtEnd( writecode{
						parameter.Value = $entity.$propertyName;
						if(DotNET::System::String::IsNullOrEmpty($entity.$propertyName)){
							parameter.Value = DotNET::System::DBNull::Value;
						}
						sqlCommand.Parameters.Add(parameter);
					}.Children(), fieldsBlock.Children());

				}
				else
				{
					XplNodeList::CopyNodesAtEnd( writecode{
					parameter.Value = $entity.$propertyName;
					sqlCommand.Parameters.Add(parameter);
					}.Children(), fieldsBlock.Children());
				}
			}

			string^ parameterName = entity.Identifier;
			XplClassMembersList^ updateFunction = writecode{%
				// <summary>
				// Función que actualiza un $entityType$ en la base de datos. 
				// </summary>
				// <param name="$entity$">$entityType$ a actualizar</param>
				// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void Update($entityType^ $entity)
				{
					if($entity == null)
					{
						throw new ArgumentException("The argument can't be null", $parameterName);
					}

					// Construir un comando para actualizar
					string^ commandName = $sqlUpdate;
					$commandType^ sqlCommand = dataAccess.GetNewCommand(commandName, dbConnection, dbTransaction);
					$fieldsBlockCommandType;
					
					// Establece los parametros de actualización
					$parameterType^ parameter = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
					parameter.Value = $entity.Id;
					sqlCommand.Parameters.Add(parameter);

					$fieldsBlock;
					
					// Ejecuta la actualización
					sqlCommand.ExecuteNonQuery();

					// Actualizar los campos new y changed
					$entity.IsNew = false;
					$entity.Changed = false;
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(updateFunction.Children(), target.Children());
				}
		}
		// Genera la Función DeleteEntity para borrar una entity
		static void GenerateDelete(iname void modelName, iname void tableName){
			string^ entityStringName = modelName.Identifier;

			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ sqlCommand = "Delete" + tableName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			string^ nameId = "id" + modelName.Identifier;

			XplFunctionBody^ fieldsBlockCommandType = new XplFunctionBody();
			if(isMobil)
			{
				sqlCommand = "DELETE FROM [" + tableName.Identifier + "] WHERE " + nameId + " = @" + nameId;
			}
			else
			{
				fieldsBlockCommandType.Children().InsertAtEnd(
					writecode(
						sqlCommand.CommandType = CommandType::StoredProcedure
						)
					);
			}
			
			XplFunctionBody^ fieldsBlockRelations = new XplFunctionBody();
			for(int i = 0; i < listaRelaciones.Count; i++)
			{
				
				Relation^ relation = (Relation^)listaRelaciones[i];
				if( !(relation.recursiveLoad && relation.deleteCascade))
				{
					continue;
				}

				XplType^ dataAccessRelation = new XplType();
				dataAccessRelation.set_typename(relation.referencedType.Identifier+"DataAccess");
				XplIName^ propertyNameRelation = relation.fieldName;

				if(relation.relationType == 2)
				{					
					XplIName^ functionName = new XplIName("Delete"+relation.referencedType.Identifier+"Collection");

					XplNodeList::CopyNodesAtEnd( writecode{
						if ( $entity.$propertyNameRelation != null )
						{
							this.$functionName((new $dataAccessRelation()), $entity.$propertyNameRelation, scope);
						}
					}.Children(), fieldsBlockRelations.Children());
				}
				else
				{
					XplIName^ varDataAccess = new XplIName(ToLowerCamelCase(relation.referencedType.Identifier)+"DataAccess");
					XplNodeList::CopyNodesAtEnd( writecode{
						if ( $entity.$propertyNameRelation != null )
						{
							$dataAccessRelation $varDataAccess= new $dataAccessRelation();
							$varDataAccess.SetConnectionObjects(dbConnection, dbTransaction);
							$varDataAccess.Delete($entity.$propertyNameRelation, scope);
						}
					}.Children(), fieldsBlockRelations.Children());
				}
			}
			
			// If there are restrictions defined call check for delete
			XplFunctionBody^ blockCheckForDelete = writecode{
			{
				// Check for related data
				CheckForDelete($entity);
			}
			};
			if(listaRestricciones.Count==0) blockCheckForDelete = new XplFunctionBody();

			XplClassMembersList^ deleteFunction = writecode{%
			public:
				// <summary>
				// Función que elimina un $entityType$ de la base de datos. 
				// </summary>
				// <param name="$entity$">$entityType$ a eliminar</param>
				// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void Delete($entityType^ $entity){
					Delete($entity, null);
				}

				// <summary>
				// Función que elimina un $entityType$ de la base de datos. 
				// </summary>
				// <param name="$entity$">$entityType$ a eliminar</param>
				// <param name="scope">Estructura interna para evitar problemas de referencia circular.</param>
				// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void Delete($entityType^ $entity, DictionaryOfStringIEntity^ scope)
				{
					if($entity == null)
					{
						throw new ArgumentException("The argument can't be null");
					}

					try
					{
						// Abrir una nueva conexión e inicializar una transacción si es necesario
						if (!isGlobalTransaction)
						{
							dbConnection = dataAccess.GetNewConnection();
							dbConnection.Open();
							dbTransaction = dbConnection.BeginTransaction();
						}
						// Carga la entidad para garantizar eliminar todos los datos antiguos.
						$entity = this.Load($entity.Id, true);
						if ($entity == null)
						{
							throw new UtnEmallDataAccessException("Error al recuperar datos al intentar eliminar.");
						}

						$blockCheckForDelete;
						
						// Crea un nuevo command para eliminar
						string^ cmdText = $sqlCommand;
						$commandType^ sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
						$fieldsBlockCommandType;
						// Agrega los valores de los parametros
						$parameterType^ parameterID = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
						parameterID.Value = $entity.Id;
						sqlCommand.Parameters.Add(parameterID);

						// Ejecuta el comando
						sqlCommand.ExecuteNonQuery();

						// Elimina los objetos relacionados
						$fieldsBlockRelations;

						// Confirma la transacción si se inicio dentro de la función
						if (!isGlobalTransaction)
						{
							dbTransaction.Commit();
						}
						// Eliminamos la entidad de la lista de entidades cargadas en memoria
						inMemoryEntities.Remove($entity.Id);
						// Eliminamos la entidad del scope
						if(scope!=null)
						{
							string^ scopeKey = $entity.Id.ToString(DotNET::System::Globalization::NumberFormatInfo::InvariantInfo) + $entityStringName;
							scope.Remove(scopeKey);
						}
					}
					catch(DbException^ dbException)
					{
						// Anula la transaccion
						if (!isGlobalTransaction)
						{
							dbTransaction.Rollback();
						}
						// Relanza una excepcion personalizada
						throw new UtnEmallDataAccessException(dbException.Message, dbException);
					}
					finally
					{
						// Cierra la conexión si fue abierta dentro de la Función
						if (!isGlobalTransaction)
						{
							dbConnection.Close();
							dbConnection = null;
							dbTransaction = null;
						}
					}
				}
				
				%};

			XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(deleteFunction.Children(), target.Children());
				}
		}	

		
		static void GenerateDeleteCollection(iname void modelName, Relation^ relation){
			XplType^ entityTypeRelation = new XplType();
			entityTypeRelation.set_typename(relation.referencedType.Identifier+"Entity");

			XplType^ dataAccessTypeRelation = new XplType();
			dataAccessTypeRelation.set_typename(relation.referencedType.Identifier+"DataAccess");
			
			XplIName^ functionName = new XplIName("Delete"+relation.referencedType.Identifier+"Collection");
			XplIName^ relationName = new XplIName(relation.referencedType.Identifier);

			//Tipo para lista
			XplType^ listOfType = new XplType();
			listOfType.set_typename( "CollectionOf" + entityTypeRelation.get_typename() );

			XplClassMembersList^ saveCollectionFunction = writecode{%
				// <summary>
				// Función para eliminar una lista de entidades relacionadas desde la base de datos
				// </summary>
				// <param name="collectionDataAccess">IDataAccess de la relacion</param>
				// <param name="collection">La colección de entidades a eliminar</param>
				// <param name="scope">Estructura interna para evitar problemas de referencia circular</param>
				// <returns>True si la colección no es nula</returns>
				bool $functionName($dataAccessTypeRelation^ collectionDataAccess, $listOfType^ collection, DictionaryOfStringIEntity^ scope)
				{
					if(collection == null)
					{
						return false;
					}
					// Establece los objetos de conexión al data access de la relación.
					collectionDataAccess.SetConnectionObjects(dbConnection, dbTransaction);

					// Elimina los objetos relacionados
					for (int i = 0; i < collection.Count; i++)
					{
						collectionDataAccess.Delete( collection[i], scope);
					}

					return true;
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null)
				{
					XplNodeList::CopyNodesAtEnd(saveCollectionFunction.Children(), target.Children());
				}
		}
		// Genera la Función DBChecked para chequear si existen los procedures y la tabla en la base de datos
		static void GenerateDBChecked(iname void modelName, iname void tableName){
			string^ nameTable = tableName.Identifier;
			string^ nameProcedureDelete = "Delete" + tableName.Identifier;
			string^ nameProcedureSave = "Save" + tableName.Identifier;
			string^ nameProcedureUpdate = "Update" + tableName.Identifier;
			string^ nameProcedureNextID = "NextID" + tableName.Identifier;
			string^ nameId = "id" + modelName.Identifier;

			XplFunctionBody^ fieldsBlockCreateTable = new XplFunctionBody();

			if(isIdIdentity)
			{
				XplNodeList::CopyNodesAtEnd( writecode{
			
					DataAccessConnection::CreateTable($nameTable, fieldsName, true, fieldsType);

				}.Children(), fieldsBlockCreateTable.Children());
			}
			else
			{
				XplNodeList::CopyNodesAtEnd( writecode{
			
					DataAccessConnection::CreateTable($nameTable, fieldsName, false, fieldsType);

				}.Children(), fieldsBlockCreateTable.Children());
			}

			XplFunctionBody^ fieldsBlockProcedures = new XplFunctionBody();

			if(!isMobil)
			{
				if(!isIdIdentity)
				{
					XplNodeList::CopyNodesAtEnd( writecode{
						bool existsProcedureDelete = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureDelete);
						bool existsProcedureSave = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureSave);
						bool existsProcedureUpdate = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureUpdate);
						bool existsProcedureNextID = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureNextID);

						if (!existsProcedureDelete)
						{
							DataAccessConnection::CreateDeleteStoredProcedure($nameTable,$nameId);
						}

						if (!existsProcedureSave)
						{
							DataAccessConnection::CreateSaveStoredProcedureNonAutonumeric($nameTable, fieldsName, fieldsType);
						}

						if (!existsProcedureUpdate)
						{
							DataAccessConnection::CreateUpdateStoredProcedure($nameTable, $nameId, fieldsName, fieldsType);
						}

						if (!existsProcedureNextID)
						{
							DataAccessConnection::CreateNextIdStoredProcedure($nameTable, $nameId);
						}

					}.Children(), fieldsBlockProcedures.Children());
				}
				else
				{
					XplNodeList::CopyNodesAtEnd( writecode{
						bool existsProcedureDelete = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureDelete);
						bool existsProcedureSave = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureSave);
						bool existsProcedureUpdate = DataAccessConnection::DBCheckedStoredProcedure($nameProcedureUpdate);

						if (!existsProcedureDelete)
						{
							DataAccessConnection::CreateDeleteStoredProcedure($nameTable,$nameId);
						}

						if (!existsProcedureSave)
						{
							DataAccessConnection::CreateSaveStoredProcedure($nameTable, fieldsName, fieldsType);
						}

						if (!existsProcedureUpdate)
						{
							DataAccessConnection::CreateUpdateStoredProcedure($nameTable, $nameId, fieldsName, fieldsType);
						}
					}.Children(), fieldsBlockProcedures.Children());
				}

			}
			//Lista de campos: new {"f1", "f2", ....}
			XplExpression^ fieldsNamesExp = writecode(new string^[] = {$nameId });
			XplInitializerList^ list = (XplInitializerList^)fieldsNamesExp.FindNode("/init");
			if(list!=null){
				for(int n=0;n<listaCampos.Count;n++){
					string^ nombreCampo = ToLowerCamelCase(((XplIName^)listaCampos[n]).Identifier);
					list.Children().InsertAtEnd(
						writecode($nombreCampo)
						);
				}
			}

			//Lista de tipos: new { gettype(int), ....}
			XplExpression^ fieldsTypesExp = writecode(new Type^[] = {});
			list = (XplInitializerList^)fieldsTypesExp.FindNode("/init");
			if(list!=null)
			{
				list.Children().InsertAtEnd(
					writecode(typeof(int))
					);

				for(int n=0;n<listaTipos.Count;n++){
					XplType^ tipoCampo = ((XplType^)listaTipos[n]);
					
					if(tipoCampo.get_typeStr() == "UtnEmall.Utils.Image"){
						tipoCampo = new XplType();
						tipoCampo.set_typename("DotNET::System::Drawing::Image");
					}

					list.Children().InsertAtEnd(
						writecode(typeof($tipoCampo))
						);
				}
			}
					
			XplClassMembersList^ dbChequedFunction = writecode{%
				// <summary>
				// Función que controla y crea la tabla y los procedimientos almacenados para esta clase. 
				// </summary>
				static void DbChecked()
				{
					if (dbChecked)
					{
						return;
					}

					string^[] fieldsName = $fieldsNamesExp;
					Type^[] fieldsType = $fieldsTypesExp;

					bool existsTable = DataAccessConnection::DBCheckedTable($nameTable);
					
					if (!existsTable)
					{
						$fieldsBlockCreateTable;
					}

					$fieldsBlockProcedures;

					dbChecked = true;
				
				}
				
				%};


				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null)
				{
					XplNodeList::CopyNodesAtEnd(dbChequedFunction.Children(), target.Children());
				}
		}

		static void SetConnectionObjects(iname void modelName){
			XplClassMembersList^ SetConnectionObjectsFunction = writecode{%
			public:
				// <summary>
				// Establece la conexión y la transacción en el caso de que una transacción global se este ejecutando
				// </summary>
				// <param name="connection">La conexión $connectionType$</param>
				// <param name="transaction">La transacción global $transactionType$</param>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void SetConnectionObjects($connectionType^ connection, $transactionType^ transaction)
				{
					if (connection == null)
					{
						throw new ArgumentException("The connection cannot be null");
					}

					this.dbConnection = connection;
					this.dbTransaction = transaction;
					this.isGlobalTransaction = true;
				}
			%};

			XplClass^ target = GetDataAccessClass(modelName.Identifier);
			if(target!=null)
			{
				XplNodeList::CopyNodesAtEnd(SetConnectionObjectsFunction.Children(), target.Children());
			}
		}
		static void GenerateSetProperties(iname void modelName){

			XplClassMembersList^ listaMiembros = null;
			
			XplFunctionBody^ fieldsBlock = new XplFunctionBody();
			string^ nameIdProperty = "id" + modelName.Identifier;
			XplIName^ nameIdPropertyStatic = new XplIName("DBId" + modelName.Identifier);

			//Inserto los miembros en la clase actual
			listaMiembros = writecode{% 
				public: const string^ $nameIdPropertyStatic = $nameIdProperty;
			%};
			XplNodeList::CopyNodesAtEnd(listaMiembros.Children(), context.CurrentClass.Children());

			fieldsBlock.Children().InsertAtEnd(
					writecode(
						properties.Add($nameIdProperty, typeof(int))
						)
					);

			for(int i = 0; i<listaCampos.Count; i++)
			{
				string^ propertya = ToLowerCamelCase(((XplIName^)listaCampos[i]).Identifier);
				string^ propertyb = ((XplIName^)listaCampos[i]).Identifier;
				XplIName^ propertyaStatic = new XplIName( "DB" + propertyb);
				XplType^ typeProperty = ((XplType^)listaTipos[i]);

				if(typeProperty.get_typeStr() == "UtnEmall.Utils.Image"){
					typeProperty.set_typename(NativeTypes::String);
				}

				fieldsBlock.Children().InsertAtEnd(
					writecode(
						properties.Add($propertya, typeof($typeProperty))
						)
					);				

				listaMiembros = writecode{% public: const string^ $propertyaStatic = $propertya;  %};
				XplNodeList::CopyNodesAtEnd(listaMiembros.Children(), context.CurrentClass.Children());
			}

			XplClassMembersList^ SetPropertiesFunction = writecode{%
				// <summary>
				// Agrega al diccionario las propiedades que pueden ser usadas como primer parametro de los metodos LoadWhere
				// </summary>
				static void SetProperties()
				{
					properties = new dict();
					properties.Add("timestamp", typeof(DateTime));
					$fieldsBlock;
				}			
			%};

			XplClass^ target = GetDataAccessClass(modelName.Identifier);
			if(target!=null)
			{
				XplNodeList::CopyNodesAtEnd(SetPropertiesFunction.Children(), target.Children());
			}
		}
		// Crea la Funciónes correspondientes para cada uno de los campos relacionados.
		// Se basa en la cardinalidad de la relacion para decidir que Funciónes crear.
		static void GenerateFunctionRelations(iname void modelName, iname void tableName){
			bool update = false;

			for(int i = 0; i < listaRelaciones.Count; i++)
			{
				Relation^ relation = (Relation^)listaRelaciones[i];
				
				switch(relation.relationType)
				{
					case 1:
						//case RelationTypes::UnoAUno:
						if(relation.recursiveLoad)
						{
							GenerateLoadRelations(modelName, tableName, relation);
							if(relation.recursiveSave)
							{
								update = true;
							}
						}
						break;
					
					case 2:
						//case RelationTypes::UnoAMuchos:
						if(relation.recursiveLoad)
						{
							GenerateLoadRelationsUnoMuchos(modelName, tableName, relation);
							if(relation.recursiveSave)
							{
								GenerateSaveCollection(modelName, relation);
							}
						}

						if(relation.deleteCascade)
						{
							GenerateDeleteCollection(modelName, relation);
						}
						break;					
					
					case 3:
						//case RelationTypes::MuchosAUno:						
						if(relation.generateRelation)
						{
							GenerateLoadBy(modelName, relation);
						}
						if(relation.recursiveLoad)
						{
							GenerateLoadRelations(modelName, tableName, relation);
							if(relation.recursiveSave)
							{
								update = true;
							}
						}
						break;
					
					case 4:
						//case RelationTypes::MuchosAMuchos:
						break;					
				}
			}
			if(update)
			{
				GenerateUpdate(modelName, tableName);
			}
		}
		static string^ ToLowerCamelCase(string^ valor){
			string^ primeraLetra = valor.Substring(0,1).ToLower();
			string^ ultimasLetras = valor.Substring(1);
			string^ resultado = primeraLetra + ultimasLetras;
			return resultado;
		}
		// Genera la Función Save para cada una de las colecciones
		static void GenerateSaveCollection(iname void modelName, Relation^ relation){
			XplType^ entityType = new XplType();
			entityType.set_typename(modelName.Identifier+"Entity");

			XplType^ entityTypeRelation = new XplType();
			entityTypeRelation.set_typename(relation.referencedType.Identifier+"Entity");

			XplType^ dataAccessTypeRelation = new XplType();
			dataAccessTypeRelation.set_typename(relation.referencedType.Identifier+"DataAccess");
			
			XplIName^ propertyName =  new XplIName(modelName.Identifier);
			if(relation.parentName!=null)
			{
				propertyName = new XplIName(relation.parentName.Identifier);
			}

			string^ propertyNameRelationString = ToLowerCamelCase(modelName.Identifier);
			
			XplIName^ propertyNameRelation = relation.fieldName;
			XplIName^ functionName = new XplIName("Save"+relation.referencedType.Identifier+"Collection");
			
			string^ nameId = "id" + modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			if(relation.referencedType.Identifier == modelName.Identifier)
			{
				nameId = "id" + relation.parentName.Identifier;
				nameIdParameter = "@id" + relation.parentName.Identifier;
			}
			string^ nameTableRelated = relation.referencedType.Identifier;
			string^ namecolumnRelatedParameter= "@id" + relation.referencedType.Identifier;
			string^ namecolumnRelated = "id" + relation.referencedType.Identifier;

			//Tipo para lista
			XplType^ listOfType = new XplType();
			listOfType.set_typename( "CollectionOf" + entityTypeRelation.get_typename() );

			XplClassMembersList^ saveCollectionFunction = writecode{%
				// <summary>
				// Actualiza la base de datos para reflejar el estado actual de la lista.
				// </summary>
				// <param name="collectionDataAccess">El IDataAccess de la relación</param>
				// <param name="parent">El objeto padre</param>
				// <param name="collection">una colección de items</param>
				// <param name="isNewParent">Si el padre es un objeto nuevo</param>
				// <param name="scope">Estructura de datos interna para evitar problemas de referencia circular</param>
				// <exception cref="UtnEmallDataAccessException">
				// Si una DbException ocurre cuando se accede a la base de datos
				// </exception>
				void $functionName($dataAccessTypeRelation^ collectionDataAccess, $entityType^ parent, $listOfType^ collection, bool isNewParent, DictionaryOfStringIEntity^ scope)
				{
					if(collection == null)
					{
						return;
					}
					// Establece los objetos de conexión
					collectionDataAccess.SetConnectionObjects(dbConnection, dbTransaction);

					// Establece la relación padre/hijo
					for (int i = 0; i < collection.Count; i++)
					{
						bool changed = collection[i].Changed;
						collection[i].$propertyName = parent;
						collection[i].Changed = changed;
					}

					// Si el padre es nuevo guarda todos los hijos, sino controla las diferencias con la base de datos.
					if (isNewParent)
					{
						for (int i = 0; i < collection.Count; i++)
						{
							collectionDataAccess.Save(collection[i], scope);
						}
					}
					else
					{
						// Controla los hijos que ya no son parte de la relación
						string^ idList = "0";
						if(collection.Count > 0)
						{	
							idList = "" + (collection[0]).Id;
						}

						for (int i = 1; i < collection.Count; i++)
						{
							idList += ", " + (collection[i]).Id;
						}

						// Retorna los ids que ya no existe en la colección actual
						string^ command = "SELECT "+ $namecolumnRelated +" FROM ["+ $nameTableRelated + "] " +
											"WHERE "+ $nameId +" = "+ $nameIdParameter +" AND "+ $namecolumnRelated +" NOT IN ("+idList+")";

						$commandType^ sqlCommand = dataAccess.GetNewCommand(command, dbConnection, dbTransaction);

						$parameterType^ sqlParameterId = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
						sqlParameterId.Value = parent.Id;
						sqlCommand.Parameters.Add(sqlParameterId);

						IDataReader^ reader = sqlCommand.ExecuteReader();
						$listOfType^ objectsToDelete = new $listOfType();

						// Inserta los id en una lista
						ListInt listId = new ListInt();
						while (reader.Read())
						{
							listId.Add(reader.GetInt32(0));
						}
						reader.Close();

						// Carga los items a ser eliminados
						foreach(int id in listId)
						{
							$entityTypeRelation^ entityToDelete = collectionDataAccess.Load(id, scope);
							objectsToDelete.Add( entityToDelete );
						}

						// Esto se realiza porque el reader debe ser cerrado despues de eliminar las entidades
						for (int i = 0; i < objectsToDelete.Count; i++)
						{
							collectionDataAccess.Delete(objectsToDelete[i], scope);
						}

						zoe::lang::DateTime timestamp;						
						// Controla todas las propiedades de los items de la colección
						// para verificar si alguno cambio
						for (int i = 0; i < collection.Count; i++)
						{   
							$entityTypeRelation^ item = collection[i];							
							if (!item.Changed && !item.IsNew)
							{
								// Crea el command
								string^ sql = "SELECT timestamp FROM ["+$nameTableRelated+"] WHERE "+ $namecolumnRelated +" = "+ $namecolumnRelatedParameter;						
								$commandType^ sqlCommandTimestamp = dataAccess.GetNewCommand(sql, dbConnection, dbTransaction);
								// Establece los datos a los parametros del command
								$parameterType^ sqlParameterIdPreference = dataAccess.GetNewDataParameter($namecolumnRelatedParameter, DbType::Int32);
								sqlParameterIdPreference.Value = item.Id;
								sqlCommandTimestamp.Parameters.Add(sqlParameterIdPreference);

								timestamp = (zoe::lang::DateTime)sqlCommandTimestamp.ExecuteScalar();
								if (item.Timestamp!=timestamp)
								{
									item.Changed = true;
								}
							}
							// Guarda el item si cambio o es nuevo
							if(item.Changed || item.IsNew)
							{
								collectionDataAccess.Save(item);
							}
						}
					}
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null)
				{
					XplNodeList::CopyNodesAtEnd(saveCollectionFunction.Children(), target.Children());
				}
		}
		// Genera la Función LoadRelations para cardinalidad uno a muchos
		static void GenerateLoadRelationsUnoMuchos(iname void modelName, iname void sqlTableName, Relation^ relation){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			XplIName^ relationDataAccess = new XplIName(ToLowerCamelCase(relation.referencedType.Identifier)+"DataAccess");
			string^ nameId = "id" + modelName.Identifier;
			string^ nameTable = sqlTableName.Identifier; // modelName.Identifier;
			
			string^ nameIdParameter = "@id" + modelName.Identifier;

			string^ namecolumnRelated = "id" + relation.fieldName.Identifier;

			XplType^ entityTypeRelation = new XplType();
			entityTypeRelation.set_typename(relation.referencedType.Identifier+"Entity");
			XplType^ dataAccessTypeRelation = new XplType();
			dataAccessTypeRelation.set_typename(relation.referencedType.Identifier+"DataAccess");

			XplIName^ functionLoadByName = new XplIName("LoadBy" + modelName.Identifier + "Collection");

			XplIName^ propertyName = relation.fieldName;

			XplIName^ functionName = new XplIName("LoadRelation" + relation.fieldName.Identifier);

			//Lista de tipos generica
			XplType^ listOfType = new XplType();
			listOfType.set_typename( "CollectionOf" + entityTypeRelation.get_typename() );

			XplClassMembersList^ loadRelationsFunction = writecode{%
				public:
				// <summary>
				// Función que carga la relacion $propertyName$ desde la base de datos 
				// </summary>
				// <param name="$entity$">Entidad padre $entityType$</param>
				// <param name="scope">Estructura de datos interna para evitar los problemas de referencia circular</param>
	    		// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>
				void $functionName($entityType^ $entity, DictionaryOfStringIEntity^ scope)
				{
					if($entity == null)
					{
						throw new ArgumentException("The argument can't be null");
					}
					// Crea un objeto data access para los objetos relacionados
					$dataAccessTypeRelation^ $relationDataAccess = new $dataAccessTypeRelation();
					// Establece los objetos de la conexión al data access de la relacion
					$relationDataAccess.SetConnectionObjects(dbConnection, dbTransaction);
					// Carga los objetos relacionadoss
					$entity.$propertyName = $relationDataAccess.$functionLoadByName($entity.Id, scope);
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null)
				{
					XplNodeList::CopyNodesAtEnd(loadRelationsFunction.Children(), target.Children());
				}
		}
		// Genera la Función LoadRelations para cardinalidad muchos a uno y uno a uno.
		static void GenerateLoadRelations(iname void modelName, iname void sqlTableName, Relation^ relation){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			XplIName^ relationDataAccess = new XplIName(ToLowerCamelCase(relation.referencedType.Identifier)+"DataAccess");

			string^ nameId = "id" + modelName.Identifier;
			string^ nameTable = sqlTableName.Identifier; // modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;
			
			string^ namecolumnRelated = "id" + relation.fieldName.Identifier;

			XplType^ entityTypeRelation = new XplType();
			entityTypeRelation.set_typename(relation.referencedType.Identifier+"Entity");
			XplType^ dataAccessTypeRelation = new XplType();
			dataAccessTypeRelation.set_typename(relation.referencedType.Identifier+"DataAccess");

			XplIName^ propertyName = relation.fieldName;

			XplIName^ className = new XplIName("LoadRelation" + relation.fieldName.Identifier);
			
			XplExpression^ loadSubRelations = writecode(true);
			
			if(!relation.loadSubRelations)loadSubRelations = writecode(false);

			XplClassMembersList^ loadRelationsFunction = writecode{%
				public:
				// <summary>
				// Función que carga la relacion $propertyName$ desde la base de datos 
				// </summary>
				// <param name="$entity$">Padre: $entityType$</param>
	    		// <exception cref="ArgumentNullException">
				// Si <paramref name="$entity$"/> no es un <c>$entityType$</c>.
				// </exception>		
				void $className($entityType^ $entity, DictionaryOfStringIEntity^ scope)
				{
					if($entity == null)
					{
						throw new ArgumentException("The argument can't be null");
					}
					bool closeConnection = false;
					try
					{
						// Crea una nueva conexión si es necesario
						if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
						{
							closeConnection = true;
							dbConnection = dataAccess.GetNewConnection();
							dbConnection.Open();
						}
						// Crea un nuevo command
						string^ cmdText = "SELECT " + $namecolumnRelated +" FROM ["+ $nameTable +"] WHERE "+ $nameId +" = "+ $nameIdParameter;
						$commandType^ sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
						$parameterType^ parameter = dataAccess.GetNewDataParameter($nameIdParameter, DbType::Int32);
						// Establece los valores a los parametros del command
						parameter.Value = $entity.Id;
						sqlCommand.Parameters.Add(parameter);
						// Execute commands
						object^ idRelation = sqlCommand.ExecuteScalar();
						if (idRelation != null && (int)idRelation > 0)
						{
							// Create data access objects and set connection objects
							$dataAccessTypeRelation^ $relationDataAccess = new $dataAccessTypeRelation();
							$relationDataAccess.SetConnectionObjects(dbConnection, dbTransaction);
							// Carga los objetos relacionados
							$entity.$propertyName = $relationDataAccess.Load((int)idRelation, $loadSubRelations, scope);
						}
					}
					catch (DbException^ dbException)
					{
						// Relanza una excepcion personalizada
						throw new UtnEmallDataAccessException(dbException.Message, dbException);
					}
					finally
					{
						// Cierra la conexión si fue inicializada
						if(closeConnection)
						{
							dbConnection.Close();
						}
					}
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadRelationsFunction.Children(), target.Children());
				}
		}
		// Genera la Función LoadBy para cardinalidad uno a muchos.
		static void GenerateLoadByUnoMuchos(iname void modelName, Relation^ relation){
			XplIName^ entity = new XplIName(ToLowerCamelCase(modelName.Identifier));
			string^ nameId = "id" + modelName.Identifier;
			
			string^ nameIdParameter = "@id" + modelName.Identifier;

			string^ namecolumnRelated = "id" + relation.referencedType.Identifier;
			XplIName^ nameColumnRelatedInt = new XplIName("id" + relation.referencedType.Identifier);
			string^ namecolumnRelatedParameter = "@id" +relation.referencedType.Identifier;

			string^ nameTableRelated = relation.referencedType.Identifier;

			XplType^ entityType = new XplType();
			entityType.set_typename(modelName.Identifier+"Entity");
			
			XplIName^ propertyName = relation.fieldName;

			XplIName^ className = new XplIName("LoadBy" + relation.referencedType.Identifier);


			XplClassMembersList^ loadByFunction = writecode{%
				public:
				// <summary>
				// Función para cargar un $entityType$ por un $propertyName$ desde la base de datos. 
				// </summary>
				// <param name="$nameColumnRelatedInt$">$propertyName$ Id</param>
				$entityType^ $className(int $nameColumnRelatedInt, DictionaryOfStringIEntity^ scope)
				{
					$entityType^ $entity;
					bool closeConnection = false;
					try
					{
						// Crea una conexión si es necesario
						if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
						{
							closeConnection = true;
							dbConnection = dataAccess.GetNewConnection();
							dbConnection.Open();
						}
						// Crea un command
						string^ cmdText = "SELECT "+ $nameId +" FROM ["+ $nameTableRelated +"] WHERE "+ $namecolumnRelated +" = "+ $namecolumnRelatedParameter;
						$commandType sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
						// Establece los valores de los parametros del command
						$parameterType^ parameter = dataAccess.GetNewDataParameter($namecolumnRelatedParameter, DbType::Int32);
						parameter.Value = $nameColumnRelatedInt;
						sqlCommand.Parameters.Add(parameter);

						// Crea un data reader y carga los objetos relacionado
						IDataReader^ reader = sqlCommand.ExecuteReader();
						$entity = new $entityType();

						if (reader.Read())
						{
							int id = reader.GetInt32(0);
							reader.Close();
							$entity = ($entityType^)Load(id, scope);
						}
						else
						{
							reader.Close();
						}						
					}
					finally
					{
						// Cierra la conexión si fue inicializada
						if(closeConnection)
						{
							dbConnection.Close();
						}
					}
					// retorna el objeto relacionado
					return $entity;
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadByFunction.Children(), target.Children());
				}
		}
		// Genera la Función LoadBy para cardinalidad muchos a uno y uno a uno.
		static void GenerateLoadBy(iname void modelName, Relation^ relation){
			XplIName^ entityList = new XplIName(ToLowerCamelCase(modelName.Identifier)+ "List");
			string^ nameId = "id" + modelName.Identifier;
			
			string^ nameTable = modelName.Identifier;
			string^ nameIdParameter = "@id" + modelName.Identifier;

			string^ namecolumnRelated = "id" + relation.referencedType.Identifier;
			XplIName^ nameColumnRelatedInt = new XplIName("id" + relation.referencedType.Identifier);
			string^ namecolumnRelatedParameter = "@id" + relation.referencedType.Identifier;

			if(relation.referencedType.Identifier == modelName.Identifier)
			{
				namecolumnRelated = "id" + relation.parentName.Identifier;
				namecolumnRelatedParameter= "@id" + relation.parentName.Identifier;
			}

			XplIName^ propertyName = relation.fieldName;

			XplIName^ className = new XplIName("LoadBy" + relation.referencedType.Identifier + "Collection");

			//Tipo para lista
			XplIName^ listOfTypeName = new XplIName("CollectionOf" + modelName.Identifier + "Entity");
			XplType^ entityType = new XplType();
			entityType.set_typename( modelName.Identifier + "Entity" );
			XplType^ listOfType = new XplType();
			listOfType.set_typename( listOfTypeName.Identifier );

			XplClassMembersList^ loadByFunction = writecode{%
				UtnEmall::Utils::List::NewCollection( $listOfTypeName, gettype($entityType^) );
				public:
				// <summary>
				// Función que carga una lista de $entityType$ desde la base de datos por $nameColumnRelatedInt$. 
				// </summary>
				// <param name="$nameColumnRelatedInt$">Foreing key</param>
				// <param name="scope">Estructura de datos interna para evitar referencias circulares</param>
				// <returns>List of $entityType$</returns>
				$listOfType^ $className(int $nameColumnRelatedInt, DictionaryOfStringIEntity^ scope)
				{
					$listOfType^ $entityList;
					bool closeConnection = false;
					try
					{
						// Crea una nueva conexión
						if(dbConnection == null || dbConnection.State.CompareTo(DotNET::System::Data::ConnectionState::Closed) == 0)
						{
							closeConnection = true;
							dbConnection = dataAccess.GetNewConnection();
							dbConnection.Open();
						}
						// Crea un command
						string^ cmdText = "SELECT "+ $nameId +" FROM ["+ $nameTable +"] WHERE "+ $namecolumnRelated +" = "+ $namecolumnRelatedParameter;
						$commandType sqlCommand = dataAccess.GetNewCommand(cmdText, dbConnection, dbTransaction);
						// Establece los parametros del command
						$parameterType^ parameter = dataAccess.GetNewDataParameter($namecolumnRelatedParameter, DbType::Int32);
						parameter.Value = $nameColumnRelatedInt;
						sqlCommand.Parameters.Add(parameter);

						// Crea un DataReader
						IDataReader^ reader = sqlCommand.ExecuteReader();
						$entityList = new $listOfType();
						// Carga los ids de los objetos relacionados en una lista de int.
						ListInt listId = new ListInt();
						while (reader.Read())
						{
							listId.Add(reader.GetInt32(0));
						}
						reader.Close();

						// Carga los objetos relacionados y los agrega a la coleccion
						foreach(int id in listId)
						{
							$entityList.Add(Load( id, scope));
						}
					}
					catch(DbException^ dbException)
					{
						// Relanzamos una excepcion personalizada
						throw new UtnEmallDataAccessException(dbException.Message, dbException);
					}
					finally
					{
						// Cerrar la conexión si fue inicializada
						if(closeConnection)
						{
							dbConnection.Close();
						}
					}
					// retornamos la lista de objetos relacionados
					return $entityList;
				}
				
				%};

				XplClass^ target = GetDataAccessClass(modelName.Identifier);
				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadByFunction.Children(), target.Children());
				}

				XplClassMembersList^ loadByFunctionOverWrite = writecode{%
					UtnEmall::Utils::List::NewCollection( $listOfTypeName, gettype($entityType^) );
					public:
					// <summary>
					// Función para cargar una lista de $entityType$ desde la base de datos por $nameColumnRelatedInt$. 
					// </summary>
					// <param name="$nameColumnRelatedInt$">columna Foreing key</param>
					// <returns>IList de $entityType$</returns>
					$listOfType^ $className(int $nameColumnRelatedInt)
					{
						return $className($nameColumnRelatedInt, null);
					}				
				%};

				if(target!=null){
					XplNodeList::CopyNodesAtEnd(loadByFunctionOverWrite.Children(), target.Children());
				}
		}

		static Hashtable^ clases = new Hashtable();		
		static XplClass^ GetDataAccessClass(string^ modelName){
			if(clases.ContainsKey(modelName+"DataAccess")){
				return (XplClass^)clases[modelName+"DataAccess"];
			}
			else{
				XplClass^ myClass = (XplClass^)context.CurrentNamespace.FindNode("/@XplClass[name='"+modelName+"DataAccess"+"']");
				clases.Add(modelName+"DataAccess", myClass);
				return myClass;
			}
		}

	}


	// Factory class Relation para declarar Relaciones entre entitys
	public factory class Relation{ 
	public:
		XplIName^ 	referencedType, 
					fieldName, 
					parentName;
					
		int 		relationType;
		
		bool 		recursiveLoad, 
					recursiveSave, 
					deleteCascade, 
					generateRelation,
					loadSubRelations;
	}

	public factory class DeleteRestriction{
	public:
		XplIName^	referencedType,
					fieldName;
		string^		messageToUser;
	}
	// Factory class para expresar tipos de relaciones entre entity.
	public factory class RelationTypes{
	public: 
			static int UnoAUno = 1;
			static int UnoAMuchos = 2;
			static int MuchosAUno = 3;
			static int MuchosAMuchos = 4;
	}
	
	public factory class Image{
	}
}
